"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KinesisStream = void 0;
const constructs_1 = require("constructs");
const kinesis = __importStar(require("aws-cdk-lib/aws-kinesis"));
const lambda = __importStar(require("aws-cdk-lib/aws-lambda"));
const lambdaEventSources = __importStar(require("aws-cdk-lib/aws-lambda-event-sources"));
const Construct_1 = require("./Construct");
const Function_1 = require("./Function");
/////////////////////
// Construct
/////////////////////
/**
 * The `KinesisStream` construct is a higher level CDK construct that makes it easy to create a [Kinesis Data Stream](https://aws.amazon.com/kinesis/data-streams/). You can create a stream and add a list of consumers to it.
 * This construct makes it easy to define a stream and its consumers. It also internally connects the consumers and the stream together.
 */
class KinesisStream extends constructs_1.Construct {
    constructor(scope, id, props) {
        super(scope, id);
        this.props = props || {};
        this.cdk = {};
        this.functions = {};
        this.permissionsAttachedForAllConsumers = [];
        this.createStream();
        // Create Consumers
        if (props === null || props === void 0 ? void 0 : props.consumers) {
            for (const consumerName in props.consumers) {
                this.addConsumer(this, consumerName, props.consumers[consumerName]);
            }
        }
    }
    /**
     * The ARN of the internally created Kinesis Stream
     */
    get streamArn() {
        return this.cdk.stream.streamArn;
    }
    /**
     * The name of the internally created Kinesis Stream
     */
    get streamName() {
        return this.cdk.stream.streamName;
    }
    /**
     * Add consumers to a stream after creating it
     *
     * @example
     * ```js
     * stream.addConsumers(stack, {
     *   consumer1: "src/function.handler"
     * })
     * ```
     */
    addConsumers(scope, consumers) {
        Object.keys(consumers).forEach((consumerName) => {
            this.addConsumer(scope, consumerName, consumers[consumerName]);
        });
    }
    /**
     * Attaches the given list of permissions to all the consumers. This allows the functions to access other AWS resources.
     *
     * @example
     *
     * ```js
     * stream.attachPermissions(["s3"]);
     * ```
     */
    attachPermissions(permissions) {
        Object.values(this.functions).forEach((fn) => fn.attachPermissions(permissions));
        this.permissionsAttachedForAllConsumers.push(permissions);
    }
    /**
     * Attaches the given list of permissions to a specific consumer. This allows that function to access other AWS resources.
     *
     * @example
     * ```js
     * stream.attachPermissionsToConsumer("consumer1", ["s3"]);
     * ```
     */
    attachPermissionsToConsumer(consumerName, permissions) {
        if (!this.functions[consumerName]) {
            throw new Error(`The "${consumerName}" consumer was not found in the "${this.node.id}" KinesisStream.`);
        }
        this.functions[consumerName].attachPermissions(permissions);
    }
    /**
     * Get the function for a specific consumer
     *
     * @example
     * ```js
     * stream.getFunction("consumer1");
     * ```
     */
    getFunction(consumerName) {
        return this.functions[consumerName];
    }
    getConstructMetadata() {
        return {
            type: "KinesisStream",
            data: {
                streamName: this.cdk.stream.streamName,
                consumers: Object.entries(this.functions).map(([name, fn]) => ({
                    name,
                    fn: (0, Construct_1.getFunctionRef)(fn),
                })),
            },
        };
    }
    createStream() {
        const { cdk } = this.props;
        const app = this.node.root;
        const id = this.node.id;
        if ((0, Construct_1.isCDKConstruct)(cdk === null || cdk === void 0 ? void 0 : cdk.stream)) {
            this.cdk.stream = cdk === null || cdk === void 0 ? void 0 : cdk.stream;
        }
        else {
            const kinesisStreamProps = ((cdk === null || cdk === void 0 ? void 0 : cdk.stream) || {});
            this.cdk.stream = new kinesis.Stream(this, "Stream", Object.assign({ streamName: app.logicalPrefixedName(id) }, kinesisStreamProps));
        }
    }
    addConsumer(scope, consumerName, consumer) {
        var _a, _b;
        // normalize consumer
        let consumerFunction, consumerProps;
        if (consumer.function) {
            consumer = consumer;
            consumerFunction = consumer.function;
            consumerProps = (_a = consumer.cdk) === null || _a === void 0 ? void 0 : _a.eventSource;
        }
        else {
            consumerFunction = consumer;
        }
        consumerProps = Object.assign({ startingPosition: lambda.StartingPosition.LATEST }, (consumerProps || {}));
        // create function
        const fn = Function_1.Function.fromDefinition(scope, `Consumer_${this.node.id}_${consumerName}`, consumerFunction, (_b = this.props.defaults) === null || _b === void 0 ? void 0 : _b.function, `The "defaults.function" cannot be applied if an instance of a Function construct is passed in. Make sure to define all the consumers using FunctionProps, so the KinesisStream construct can apply the "defaults.function" to them.`);
        this.functions[consumerName] = fn;
        // create event source
        const eventSource = new lambdaEventSources.KinesisEventSource(this.cdk.stream, consumerProps);
        fn.addEventSource(eventSource);
        // attach permissions
        this.permissionsAttachedForAllConsumers.forEach((permissions) => {
            fn.attachPermissions(permissions);
        });
        return fn;
    }
}
exports.KinesisStream = KinesisStream;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiS2luZXNpc1N0cmVhbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9LaW5lc2lzU3RyZWFtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQXVDO0FBQ3ZDLGlFQUFtRDtBQUNuRCwrREFBaUQ7QUFDakQseUZBQTJFO0FBRTNFLDJDQUEyRTtBQUMzRSx5Q0FLb0I7QUErR3BCLHFCQUFxQjtBQUNyQixZQUFZO0FBQ1oscUJBQXFCO0FBRXJCOzs7R0FHRztBQUNILE1BQWEsYUFBYyxTQUFRLHNCQUFTO0lBVzFDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBMEI7UUFDbEUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVqQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFTLENBQUM7UUFDckIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLGtDQUFrQyxHQUFHLEVBQUUsQ0FBQztRQUU3QyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFcEIsbUJBQW1CO1FBQ25CLElBQUksS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLFNBQVMsRUFBRTtZQUNwQixLQUFLLE1BQU0sWUFBWSxJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUU7Z0JBQzFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7YUFDckU7U0FDRjtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsU0FBUztRQUNsQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLFVBQVU7UUFDbkIs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QUM7UUFFSCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7Q0FDRjtBQTNMRCxzQ0EyTEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0ICogYXMga2luZXNpcyBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWtpbmVzaXNcIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWxhbWJkYVwiO1xuaW1wb3J0ICogYXMgbGFtYmRhRXZlbnRTb3VyY2VzIGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtbGFtYmRhLWV2ZW50LXNvdXJjZXNcIjtcbmltcG9ydCB7IEFwcCB9IGZyb20gXCIuL0FwcFwiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25SZWYsIFNTVENvbnN0cnVjdCwgaXNDREtDb25zdHJ1Y3QgfSBmcm9tIFwiLi9Db25zdHJ1Y3RcIjtcbmltcG9ydCB7XG4gIEZ1bmN0aW9uIGFzIEZuLFxuICBGdW5jdGlvblByb3BzLFxuICBGdW5jdGlvbklubGluZURlZmluaXRpb24sXG4gIEZ1bmN0aW9uRGVmaW5pdGlvbixcbn0gZnJvbSBcIi4vRnVuY3Rpb25cIjtcbmltcG9ydCB7IFBlcm1pc3Npb25zIH0gZnJvbSBcIi4vdXRpbC9wZXJtaXNzaW9uXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJmYWNlc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogVXNlZCB0byBkZWZpbmUgdGhlIGZ1bmN0aW9uIGNvbnN1bWVyIGZvciB0aGUgc3RyZWFtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS2luZXNpc1N0cmVhbUNvbnN1bWVyUHJvcHMge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogbmV3IEtpbmVzaXNTdHJlYW0oc3RhY2ssIFwiU3RyZWFtXCIsIHtcbiAgICogICBjb25zdW1lcnM6IHtcbiAgICogICAgIGNvbnN1bWVyMToge1xuICAgKiAgICAgICBmdW5jdGlvbjoge1xuICAgKiAgICAgICAgIGhhbmRsZXI6IFwic3JjL2NvbnN1bWVyMS5oYW5kbGVyXCIsXG4gICAqICAgICAgICAgdGltZW91dDogMzBcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgZnVuY3Rpb246IEZ1bmN0aW9uRGVmaW5pdGlvbjtcbiAgY2RrPzoge1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBpbnRlcmFsbHkgY3JlYXRlZCBldmVudCBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBuZXcgS2luZXNpc1N0cmVhbShzdGFjaywgXCJTdHJlYW1cIiwge1xuICAgICAqICAgY29uc3VtZXJzOiB7XG4gICAgICogICAgIGZ1bjoge1xuICAgICAqICAgICAgIGNkazoge1xuICAgICAqICAgICAgICAgZXZlbnRTb3VyY2U6IHtcbiAgICAgKiAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBldmVudFNvdXJjZT86IGxhbWJkYUV2ZW50U291cmNlcy5LaW5lc2lzRXZlbnRTb3VyY2VQcm9wcztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBLaW5lc2lzU3RyZWFtUHJvcHMge1xuICBkZWZhdWx0cz86IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiBwcm9wcyB0byBiZSBhcHBsaWVkIHRvIGFsbCB0aGUgTGFtYmRhIGZ1bmN0aW9ucyBpbiB0aGUgQVBJLiBUaGUgYGVudmlyb25tZW50YCwgYHBlcm1pc3Npb25zYCBhbmQgYGxheWVyc2AgcHJvcGVydGllcyB3aWxsIGJlIG1lcmdlZCB3aXRoIHBlciByb3V0ZSBkZWZpbml0aW9ucyBpZiB0aGV5IGFyZSBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIG5ldyBLaW5lc2lzU3RyZWFtKHN0YWNrLCBcIlN0cmVhbVwiLCB7XG4gICAgICogICBkZWZhdWx0czoge1xuICAgICAqICAgICBmdW5jdGlvbjoge1xuICAgICAqICAgICAgIHRpbWVvdXQ6IDIwLFxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24/OiBGdW5jdGlvblByb3BzO1xuICB9O1xuICAvKipcbiAgICogRGVmaW5lIHRoZSBmdW5jdGlvbiBjb25zdW1lcnMgZm9yIHRoaXMgc3RyZWFtXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBLaW5lc2lzU3RyZWFtKHN0YWNrLCBcIlN0cmVhbVwiLCB7XG4gICAqICAgY29uc3VtZXJzOiB7XG4gICAqICAgICBjb25zdW1lcjE6IFwic3JjL2NvbnN1bWVyMS5tYWluXCIsXG4gICAqICAgICBjb25zdW1lcjI6IHtcbiAgICogICAgICAgZnVuY3Rpb246IHtcbiAgICogICAgICAgICBoYW5kbGVyOiBcInNyYy9jb25zdW1lcjIuaGFuZGxlclwiLFxuICAgKiAgICAgICAgIHRpbWVvdXQ6IDMwXG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGNvbnN1bWVycz86IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAgRnVuY3Rpb25JbmxpbmVEZWZpbml0aW9uIHwgS2luZXNpc1N0cmVhbUNvbnN1bWVyUHJvcHNcbiAgPjtcbiAgY2RrPzoge1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBpbnRlcm5hbGx5IGNyZWF0ZWQgS2luZXNpcyBTdHJlYW1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBuZXcgS2luZXNpc1N0cmVhbShzdGFjaywgXCJTdHJlYW1cIiwge1xuICAgICAqICAgY2RrOiB7XG4gICAgICogICAgIHN0cmVhbToge1xuICAgICAqICAgICAgIHN0cmVhbU5hbWU6IFwibXktc3RyZWFtXCIsXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdHJlYW0/OiBraW5lc2lzLklTdHJlYW0gfCBraW5lc2lzLlN0cmVhbVByb3BzO1xuICB9O1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENvbnN0cnVjdFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogVGhlIGBLaW5lc2lzU3RyZWFtYCBjb25zdHJ1Y3QgaXMgYSBoaWdoZXIgbGV2ZWwgQ0RLIGNvbnN0cnVjdCB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gY3JlYXRlIGEgW0tpbmVzaXMgRGF0YSBTdHJlYW1dKGh0dHBzOi8vYXdzLmFtYXpvbi5jb20va2luZXNpcy9kYXRhLXN0cmVhbXMvKS4gWW91IGNhbiBjcmVhdGUgYSBzdHJlYW0gYW5kIGFkZCBhIGxpc3Qgb2YgY29uc3VtZXJzIHRvIGl0LlxuICogVGhpcyBjb25zdHJ1Y3QgbWFrZXMgaXQgZWFzeSB0byBkZWZpbmUgYSBzdHJlYW0gYW5kIGl0cyBjb25zdW1lcnMuIEl0IGFsc28gaW50ZXJuYWxseSBjb25uZWN0cyB0aGUgY29uc3VtZXJzIGFuZCB0aGUgc3RyZWFtIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgY2xhc3MgS2luZXNpc1N0cmVhbSBleHRlbmRzIENvbnN0cnVjdCBpbXBsZW1lbnRzIFNTVENvbnN0cnVjdCB7XG4gIHB1YmxpYyByZWFkb25seSBjZGs6IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gaW50ZXJuYWxseSBjcmVhdGVkIEtpbmVzaXMgU3RyZWFtXG4gICAgICovXG4gICAgc3RyZWFtOiBraW5lc2lzLklTdHJlYW07XG4gIH07XG4gIHByaXZhdGUgZnVuY3Rpb25zOiB7IFtjb25zdW1lck5hbWU6IHN0cmluZ106IEZuIH07XG4gIHByaXZhdGUgcmVhZG9ubHkgcGVybWlzc2lvbnNBdHRhY2hlZEZvckFsbENvbnN1bWVyczogUGVybWlzc2lvbnNbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBwcm9wczogS2luZXNpc1N0cmVhbVByb3BzO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzPzogS2luZXNpc1N0cmVhbVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMucHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICB0aGlzLmNkayA9IHt9IGFzIGFueTtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMucGVybWlzc2lvbnNBdHRhY2hlZEZvckFsbENvbnN1bWVycyA9IFtdO1xuXG4gICAgdGhpcy5jcmVhdGVTdHJlYW0oKTtcblxuICAgIC8vIENyZWF0ZSBDb25zdW1lcnNcbiAgICBpZiAocHJvcHM/LmNvbnN1bWVycykge1xuICAgICAgZm9yIChjb25zdCBjb25zdW1lck5hbWUgaW4gcHJvcHMuY29uc3VtZXJzKSB7XG4gICAgICAgIHRoaXMuYWRkQ29uc3VtZXIodGhpcywgY29uc3VtZXJOYW1lLCBwcm9wcy5jb25zdW1lcnNbY29uc3VtZXJOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgdGhlIGludGVybmFsbHkgY3JlYXRlZCBLaW5lc2lzIFN0cmVhbVxuICAgKi9cbiAgcHVibGljIGdldCBzdHJlYW1Bcm4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jZGsuc3RyZWFtLnN0cmVhbUFybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgaW50ZXJuYWxseSBjcmVhdGVkIEtpbmVzaXMgU3RyZWFtXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0cmVhbU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jZGsuc3RyZWFtLnN0cmVhbU5hbWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGNvbnN1bWVycyB0byBhIHN0cmVhbSBhZnRlciBjcmVhdGluZyBpdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBzdHJlYW0uYWRkQ29uc3VtZXJzKHN0YWNrLCB7XG4gICAqICAgY29uc3VtZXIxOiBcInNyYy9mdW5jdGlvbi5oYW5kbGVyXCJcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgYWRkQ29uc3VtZXJzKFxuICAgIHNjb3BlOiBDb25zdHJ1Y3QsXG4gICAgY29uc3VtZXJzOiB7XG4gICAgICBbY29uc3VtZXJOYW1lOiBzdHJpbmddOlxuICAgICAgICB8IEZ1bmN0aW9uSW5saW5lRGVmaW5pdGlvblxuICAgICAgICB8IEtpbmVzaXNTdHJlYW1Db25zdW1lclByb3BzO1xuICAgIH1cbiAgKTogdm9pZCB7XG4gICAgT2JqZWN0LmtleXMoY29uc3VtZXJzKS5mb3JFYWNoKChjb25zdW1lck5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgdGhpcy5hZGRDb25zdW1lcihzY29wZSwgY29uc3VtZXJOYW1lLCBjb25zdW1lcnNbY29uc3VtZXJOYW1lXSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgdGhlIGdpdmVuIGxpc3Qgb2YgcGVybWlzc2lvbnMgdG8gYWxsIHRoZSBjb25zdW1lcnMuIFRoaXMgYWxsb3dzIHRoZSBmdW5jdGlvbnMgdG8gYWNjZXNzIG90aGVyIEFXUyByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHN0cmVhbS5hdHRhY2hQZXJtaXNzaW9ucyhbXCJzM1wiXSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGF0dGFjaFBlcm1pc3Npb25zKHBlcm1pc3Npb25zOiBQZXJtaXNzaW9ucyk6IHZvaWQge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5mdW5jdGlvbnMpLmZvckVhY2goKGZuKSA9PlxuICAgICAgZm4uYXR0YWNoUGVybWlzc2lvbnMocGVybWlzc2lvbnMpXG4gICAgKTtcbiAgICB0aGlzLnBlcm1pc3Npb25zQXR0YWNoZWRGb3JBbGxDb25zdW1lcnMucHVzaChwZXJtaXNzaW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgdGhlIGdpdmVuIGxpc3Qgb2YgcGVybWlzc2lvbnMgdG8gYSBzcGVjaWZpYyBjb25zdW1lci4gVGhpcyBhbGxvd3MgdGhhdCBmdW5jdGlvbiB0byBhY2Nlc3Mgb3RoZXIgQVdTIHJlc291cmNlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogc3RyZWFtLmF0dGFjaFBlcm1pc3Npb25zVG9Db25zdW1lcihcImNvbnN1bWVyMVwiLCBbXCJzM1wiXSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGF0dGFjaFBlcm1pc3Npb25zVG9Db25zdW1lcihcbiAgICBjb25zdW1lck5hbWU6IHN0cmluZyxcbiAgICBwZXJtaXNzaW9uczogUGVybWlzc2lvbnNcbiAgKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmZ1bmN0aW9uc1tjb25zdW1lck5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgXCIke2NvbnN1bWVyTmFtZX1cIiBjb25zdW1lciB3YXMgbm90IGZvdW5kIGluIHRoZSBcIiR7dGhpcy5ub2RlLmlkfVwiIEtpbmVzaXNTdHJlYW0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmZ1bmN0aW9uc1tjb25zdW1lck5hbWVdLmF0dGFjaFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZ1bmN0aW9uIGZvciBhIHNwZWNpZmljIGNvbnN1bWVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHN0cmVhbS5nZXRGdW5jdGlvbihcImNvbnN1bWVyMVwiKTtcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgZ2V0RnVuY3Rpb24oY29uc3VtZXJOYW1lOiBzdHJpbmcpOiBGbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25zW2NvbnN1bWVyTmFtZV07XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29uc3RydWN0TWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiS2luZXNpc1N0cmVhbVwiIGFzIGNvbnN0LFxuICAgICAgZGF0YToge1xuICAgICAgICBzdHJlYW1OYW1lOiB0aGlzLmNkay5zdHJlYW0uc3RyZWFtTmFtZSxcbiAgICAgICAgY29uc3VtZXJzOiBPYmplY3QuZW50cmllcyh0aGlzLmZ1bmN0aW9ucykubWFwKChbbmFtZSwgZm5dKSA9PiAoe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZm46IGdldEZ1bmN0aW9uUmVmKGZuKSxcbiAgICAgICAgfSkpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVTdHJlYW0oKSB7XG4gICAgY29uc3QgeyBjZGsgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgYXBwID0gdGhpcy5ub2RlLnJvb3QgYXMgQXBwO1xuICAgIGNvbnN0IGlkID0gdGhpcy5ub2RlLmlkO1xuXG4gICAgaWYgKGlzQ0RLQ29uc3RydWN0KGNkaz8uc3RyZWFtKSkge1xuICAgICAgdGhpcy5jZGsuc3RyZWFtID0gY2RrPy5zdHJlYW0gYXMga2luZXNpcy5JU3RyZWFtO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBraW5lc2lzU3RyZWFtUHJvcHMgPSAoY2RrPy5zdHJlYW0gfHwge30pIGFzIGtpbmVzaXMuU3RyZWFtUHJvcHM7XG4gICAgICB0aGlzLmNkay5zdHJlYW0gPSBuZXcga2luZXNpcy5TdHJlYW0odGhpcywgXCJTdHJlYW1cIiwge1xuICAgICAgICBzdHJlYW1OYW1lOiBhcHAubG9naWNhbFByZWZpeGVkTmFtZShpZCksXG4gICAgICAgIC4uLmtpbmVzaXNTdHJlYW1Qcm9wcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWRkQ29uc3VtZXIoXG4gICAgc2NvcGU6IENvbnN0cnVjdCxcbiAgICBjb25zdW1lck5hbWU6IHN0cmluZyxcbiAgICBjb25zdW1lcjogRnVuY3Rpb25JbmxpbmVEZWZpbml0aW9uIHwgS2luZXNpc1N0cmVhbUNvbnN1bWVyUHJvcHNcbiAgKTogRm4ge1xuICAgIC8vIG5vcm1hbGl6ZSBjb25zdW1lclxuICAgIGxldCBjb25zdW1lckZ1bmN0aW9uLCBjb25zdW1lclByb3BzO1xuICAgIGlmICgoY29uc3VtZXIgYXMgS2luZXNpc1N0cmVhbUNvbnN1bWVyUHJvcHMpLmZ1bmN0aW9uKSB7XG4gICAgICBjb25zdW1lciA9IGNvbnN1bWVyIGFzIEtpbmVzaXNTdHJlYW1Db25zdW1lclByb3BzO1xuICAgICAgY29uc3VtZXJGdW5jdGlvbiA9IGNvbnN1bWVyLmZ1bmN0aW9uO1xuICAgICAgY29uc3VtZXJQcm9wcyA9IGNvbnN1bWVyLmNkaz8uZXZlbnRTb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN1bWVyRnVuY3Rpb24gPSBjb25zdW1lciBhcyBGdW5jdGlvbklubGluZURlZmluaXRpb247XG4gICAgfVxuICAgIGNvbnN1bWVyUHJvcHMgPSB7XG4gICAgICBzdGFydGluZ1Bvc2l0aW9uOiBsYW1iZGEuU3RhcnRpbmdQb3NpdGlvbi5MQVRFU1QsXG4gICAgICAuLi4oY29uc3VtZXJQcm9wcyB8fCB7fSksXG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBmdW5jdGlvblxuICAgIGNvbnN0IGZuID0gRm4uZnJvbURlZmluaXRpb24oXG4gICAgICBzY29wZSxcbiAgICAgIGBDb25zdW1lcl8ke3RoaXMubm9kZS5pZH1fJHtjb25zdW1lck5hbWV9YCxcbiAgICAgIGNvbnN1bWVyRnVuY3Rpb24sXG4gICAgICB0aGlzLnByb3BzLmRlZmF1bHRzPy5mdW5jdGlvbixcbiAgICAgIGBUaGUgXCJkZWZhdWx0cy5mdW5jdGlvblwiIGNhbm5vdCBiZSBhcHBsaWVkIGlmIGFuIGluc3RhbmNlIG9mIGEgRnVuY3Rpb24gY29uc3RydWN0IGlzIHBhc3NlZCBpbi4gTWFrZSBzdXJlIHRvIGRlZmluZSBhbGwgdGhlIGNvbnN1bWVycyB1c2luZyBGdW5jdGlvblByb3BzLCBzbyB0aGUgS2luZXNpc1N0cmVhbSBjb25zdHJ1Y3QgY2FuIGFwcGx5IHRoZSBcImRlZmF1bHRzLmZ1bmN0aW9uXCIgdG8gdGhlbS5gXG4gICAgKTtcbiAgICB0aGlzLmZ1bmN0aW9uc1tjb25zdW1lck5hbWVdID0gZm47XG5cbiAgICAvLyBjcmVhdGUgZXZlbnQgc291cmNlXG4gICAgY29uc3QgZXZlbnRTb3VyY2UgPSBuZXcgbGFtYmRhRXZlbnRTb3VyY2VzLktpbmVzaXNFdmVudFNvdXJjZShcbiAgICAgIHRoaXMuY2RrLnN0cmVhbSxcbiAgICAgIGNvbnN1bWVyUHJvcHNcbiAgICApO1xuICAgIGZuLmFkZEV2ZW50U291cmNlKGV2ZW50U291cmNlKTtcblxuICAgIC8vIGF0dGFjaCBwZXJtaXNzaW9uc1xuICAgIHRoaXMucGVybWlzc2lvbnNBdHRhY2hlZEZvckFsbENvbnN1bWVycy5mb3JFYWNoKChwZXJtaXNzaW9ucykgPT4ge1xuICAgICAgZm4uYXR0YWNoUGVybWlzc2lvbnMocGVybWlzc2lvbnMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZuO1xuICB9XG59XG4iXX0=