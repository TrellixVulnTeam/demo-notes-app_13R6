"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostgresDriver = void 0;
const compiled_query_js_1 = require("../../query-compiler/compiled-query.js");
const object_utils_js_1 = require("../../util/object-utils.js");
const PRIVATE_RELEASE_METHOD = Symbol();
class PostgresDriver {
    #config;
    #connections = new WeakMap();
    #pool = null;
    constructor(config) {
        this.#config = (0, object_utils_js_1.freeze)({ ...config });
    }
    async init() {
        // Import the `pg` module here instead at the top of the file
        // so that this file can be loaded by node without `pg` driver
        // installed. As you can see, there IS an import from `pg` at the
        // top level too, but that's only for types. It doesn't get compiled
        // into javascript. You can check the built javascript code.
        const PoolConstructor = await importPgPool();
        // Use the `pg` module's own pool. All drivers should use the
        // pool provided by the database library if possible.
        this.#pool = new PoolConstructor(this.#config);
    }
    async acquireConnection() {
        const client = await this.#pool.connect();
        let connection = this.#connections.get(client);
        if (!connection) {
            connection = new PostgresConnection(client);
            this.#connections.set(client, connection);
            // The driver must take care of calling `onCreateConnection` when a new
            // connection is created. The `pg` module doesn't provide an async hook
            // for the connection creation. We need to call the method explicitly.
            if (this.#config.onCreateConnection) {
                await this.#config.onCreateConnection(connection);
            }
        }
        return connection;
    }
    async beginTransaction(connection, settings) {
        if (settings.isolationLevel) {
            await connection.executeQuery(compiled_query_js_1.CompiledQuery.raw(`start transaction isolation level ${settings.isolationLevel}`));
        }
        else {
            await connection.executeQuery(compiled_query_js_1.CompiledQuery.raw('begin'));
        }
    }
    async commitTransaction(connection) {
        await connection.executeQuery(compiled_query_js_1.CompiledQuery.raw('commit'));
    }
    async rollbackTransaction(connection) {
        await connection.executeQuery(compiled_query_js_1.CompiledQuery.raw('rollback'));
    }
    async releaseConnection(connection) {
        const pgConnection = connection;
        pgConnection[PRIVATE_RELEASE_METHOD]();
    }
    async destroy() {
        if (this.#pool) {
            const pool = this.#pool;
            this.#pool = null;
            await pool.end();
        }
    }
}
exports.PostgresDriver = PostgresDriver;
async function importPgPool() {
    try {
        // The imported module name must be a string literal to make
        // some bundlers work. So don't move this code behind a helper
        // for example.
        const pgModule = await Promise.resolve().then(() => require('pg'));
        if ((0, object_utils_js_1.isFunction)(pgModule.Pool)) {
            return pgModule.Pool;
        }
        else {
            return pgModule.default.Pool;
        }
    }
    catch (error) {
        throw new Error('Postgres client not installed. Please run `npm install pg`');
    }
}
class PostgresConnection {
    #client;
    constructor(client) {
        this.#client = client;
    }
    async executeQuery(compiledQuery) {
        const result = await this.#client.query(compiledQuery.sql, [
            ...compiledQuery.parameters,
        ]);
        if (result.command === 'UPDATE' || result.command === 'DELETE') {
            return {
                numUpdatedOrDeletedRows: BigInt(result.rowCount),
                rows: result.rows ?? [],
            };
        }
        return {
            rows: result.rows ?? [],
        };
    }
    [PRIVATE_RELEASE_METHOD]() {
        this.#client.release();
    }
}
