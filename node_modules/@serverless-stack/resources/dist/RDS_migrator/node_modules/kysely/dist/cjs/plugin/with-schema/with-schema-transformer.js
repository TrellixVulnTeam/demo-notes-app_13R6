"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WithSchemaTransformer = void 0;
const alias_node_js_1 = require("../../operation-node/alias-node.js");
const operation_node_transformer_js_1 = require("../../operation-node/operation-node-transformer.js");
const table_node_js_1 = require("../../operation-node/table-node.js");
class WithSchemaTransformer extends operation_node_transformer_js_1.OperationNodeTransformer {
    #schema;
    #tables = new Set();
    constructor(schema) {
        super();
        this.#schema = schema;
    }
    transformSelectQuery(node) {
        return this.#transformRoot(node, (node) => super.transformSelectQuery(node));
    }
    transformInsertQuery(node) {
        return this.#transformRoot(node, (node) => super.transformInsertQuery(node));
    }
    transformUpdateQuery(node) {
        return this.#transformRoot(node, (node) => super.transformUpdateQuery(node));
    }
    transformDeleteQuery(node) {
        return this.#transformRoot(node, (node) => super.transformDeleteQuery(node));
    }
    transformCreateTable(node) {
        return this.#transformRoot(node, (node) => super.transformCreateTable(node));
    }
    transformDropTable(node) {
        return this.#transformRoot(node, (node) => super.transformDropTable(node));
    }
    transformCreateIndex(node) {
        return this.#transformRoot(node, (node) => super.transformCreateIndex(node));
    }
    transformDropIndex(node) {
        return this.#transformRoot(node, (node) => super.transformDropIndex(node));
    }
    transformCreateView(node) {
        return this.#transformRoot(node, (node) => super.transformCreateView(node));
    }
    transformDropView(node) {
        return this.#transformRoot(node, (node) => super.transformDropView(node));
    }
    transformAlterTable(node) {
        return this.#transformRoot(node, (node) => super.transformAlterTable(node));
    }
    transformTable(node) {
        const transformed = super.transformTable(node);
        if (transformed.schema || !this.#tables.has(node.table.identifier)) {
            return transformed;
        }
        return {
            ...transformed,
            schema: {
                kind: 'IdentifierNode',
                identifier: this.#schema,
            },
        };
    }
    #transformRoot(node, transform) {
        const tables = this.#collectTables(node);
        for (const table of tables) {
            this.#tables.add(table);
        }
        const transformed = transform(node);
        for (const table of tables) {
            this.#tables.delete(table);
        }
        return transformed;
    }
    #collectTables(node) {
        const tables = new Set();
        if ('from' in node && node.from) {
            this.#collectTablesFromTableExpressionNodes(node.from.froms, tables);
        }
        if ('into' in node && node.into) {
            this.#collectTablesFromTableExpressionNode(node.into, tables);
        }
        if ('table' in node && node.table) {
            this.#collectTablesFromTableExpressionNode(node.table, tables);
        }
        if ('joins' in node && node.joins) {
            this.#collectTablesFromJoins(node.joins, tables);
        }
        if ('with' in node && node.with) {
            this.#removeCommonTableExpressionTables(node.with, tables);
        }
        return tables;
    }
    #collectTablesFromTableExpressionNodes(nodes, tables) {
        for (const node of nodes) {
            this.#collectTablesFromTableExpressionNode(node, tables);
        }
    }
    #collectTablesFromJoins(nodes, tables) {
        for (const node of nodes) {
            this.#collectTablesFromTableExpressionNode(node.table, tables);
        }
    }
    #collectTablesFromTableExpressionNode(node, tables) {
        const table = table_node_js_1.TableNode.is(node)
            ? node
            : alias_node_js_1.AliasNode.is(node) && table_node_js_1.TableNode.is(node.node)
                ? node.node
                : null;
        if (table && !this.#tables.has(table.table.identifier)) {
            tables.add(table.table.identifier);
        }
    }
    #removeCommonTableExpressionTables(node, tables) {
        for (const expr of node.expressions) {
            tables.delete(expr.name.table.table.identifier);
        }
    }
}
exports.WithSchemaTransformer = WithSchemaTransformer;
