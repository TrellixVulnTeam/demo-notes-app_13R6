/// <reference types="./operation-node-transformer.d.ts" />
import { freeze } from '../util/object-utils.js';
/**
 * Transforms an operation node tree into another one.
 *
 * Kysely queries are expressed internally as a tree of objects (operation nodes).
 * `OperationNodeTransformer` takes such a tree as its input and returns a
 * transformed deep copy of it. By default the `OperationNodeTransformer`
 * does nothing. You need to override one or more methods to make it do
 * something.
 *
 * There's a method for each node type. For example if you'd like to convert
 * each identifier (table name, column name, alias etc.) from camelCase to
 * snake_case, you'd do something like this:
 *
 * ```ts
 * class CamelCaseTransformer extends OperationNodeTransformer {
 *   transformIdentifier(node: IdentifierNode): IdentifierNode {
 *     node = super.transformIdentifier(node),
 *
 *     return {
 *       ...node,
 *       identifier: snakeCase(node.identifier),
 *     }
 *   }
 * }
 *
 * const transformer = new CamelCaseTransformer()
 * const tree = transformer.transformNode(tree)
 * ```
 */
export class OperationNodeTransformer {
    nodeStack = [];
    #transformers = freeze({
        AliasNode: this.transformAlias.bind(this),
        ColumnNode: this.transformColumn.bind(this),
        IdentifierNode: this.transformIdentifier.bind(this),
        RawNode: this.transformRaw.bind(this),
        ReferenceNode: this.transformReference.bind(this),
        SelectQueryNode: this.transformSelectQuery.bind(this),
        SelectionNode: this.transformSelection.bind(this),
        TableNode: this.transformTable.bind(this),
        FromNode: this.transformFrom.bind(this),
        SelectAllNode: this.transformSelectAll.bind(this),
        FilterNode: this.transformFilter.bind(this),
        AndNode: this.transformAnd.bind(this),
        OrNode: this.transformOr.bind(this),
        ValueNode: this.transformValue.bind(this),
        ValueListNode: this.transformValueList.bind(this),
        PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
        ParensNode: this.transformParens.bind(this),
        JoinNode: this.transformJoin.bind(this),
        OperatorNode: this.transformOperator.bind(this),
        WhereNode: this.transformWhere.bind(this),
        InsertQueryNode: this.transformInsertQuery.bind(this),
        DeleteQueryNode: this.transformDeleteQuery.bind(this),
        ReturningNode: this.transformReturning.bind(this),
        CreateTableNode: this.transformCreateTable.bind(this),
        AddColumnNode: this.transformAddColumn.bind(this),
        ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
        DropTableNode: this.transformDropTable.bind(this),
        DataTypeNode: this.transformDataType.bind(this),
        OrderByNode: this.transformOrderBy.bind(this),
        OrderByItemNode: this.transformOrderByItem.bind(this),
        GroupByNode: this.transformGroupBy.bind(this),
        GroupByItemNode: this.transformGroupByItem.bind(this),
        UpdateQueryNode: this.transformUpdateQuery.bind(this),
        ColumnUpdateNode: this.transformColumnUpdate.bind(this),
        LimitNode: this.transformLimit.bind(this),
        OffsetNode: this.transformOffset.bind(this),
        OnConflictNode: this.transformOnConflict.bind(this),
        OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
        CreateIndexNode: this.transformCreateIndex.bind(this),
        DropIndexNode: this.transformDropIndex.bind(this),
        ListNode: this.transformList.bind(this),
        PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
        UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
        ReferencesNode: this.transformReferences.bind(this),
        CheckConstraintNode: this.transformCheckConstraint.bind(this),
        WithNode: this.transformWith.bind(this),
        CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
        CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
        HavingNode: this.transformHaving.bind(this),
        CreateSchemaNode: this.transformCreateSchema.bind(this),
        DropSchemaNode: this.transformDropSchema.bind(this),
        AlterTableNode: this.transformAlterTable.bind(this),
        DropColumnNode: this.transformDropColumn.bind(this),
        RenameColumnNode: this.transformRenameColumn.bind(this),
        AlterColumnNode: this.transformAlterColumn.bind(this),
        ModifyColumnNode: this.transformModifyColumn.bind(this),
        AddConstraintNode: this.transformAddConstraint.bind(this),
        DropConstraintNode: this.transformDropConstraint.bind(this),
        ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
        UnionNode: this.transformUnion.bind(this),
        CreateViewNode: this.transformCreateView.bind(this),
        DropViewNode: this.transformDropView.bind(this),
        GeneratedNode: this.transformGenerated.bind(this),
        DefaultValueNode: this.transformDefaultValue.bind(this),
        OnNode: this.transformOn.bind(this),
        ValuesNode: this.transformValues.bind(this),
    });
    transformNode = (node) => {
        if (!node) {
            return undefined;
        }
        this.nodeStack.push(node);
        const out = this.#transformers[node.kind](node);
        this.nodeStack.pop();
        return freeze(out);
    };
    transformNodeList(list) {
        if (!list) {
            return list;
        }
        return freeze(list.map(this.transformNode));
    }
    transformSelectQuery(node) {
        return {
            kind: 'SelectQueryNode',
            from: this.transformNode(node.from),
            selections: this.transformNodeList(node.selections),
            distinctOnSelections: this.transformNodeList(node.distinctOnSelections),
            distinct: node.distinct,
            joins: this.transformNodeList(node.joins),
            groupBy: this.transformNode(node.groupBy),
            orderBy: this.transformNode(node.orderBy),
            where: this.transformNode(node.where),
            modifiers: node.modifiers,
            limit: this.transformNode(node.limit),
            offset: this.transformNode(node.offset),
            with: this.transformNode(node.with),
            having: this.transformNode(node.having),
            union: this.transformNodeList(node.union),
        };
    }
    transformSelection(node) {
        return {
            kind: 'SelectionNode',
            selection: this.transformNode(node.selection),
        };
    }
    transformColumn(node) {
        return {
            kind: 'ColumnNode',
            column: this.transformNode(node.column),
        };
    }
    transformAlias(node) {
        return {
            kind: 'AliasNode',
            node: this.transformNode(node.node),
            alias: this.transformNode(node.alias),
        };
    }
    transformTable(node) {
        return {
            kind: 'TableNode',
            schema: this.transformNode(node.schema),
            table: this.transformNode(node.table),
        };
    }
    transformFrom(node) {
        return {
            kind: 'FromNode',
            froms: this.transformNodeList(node.froms),
        };
    }
    transformReference(node) {
        return {
            kind: 'ReferenceNode',
            table: this.transformNode(node.table),
            column: this.transformNode(node.column),
        };
    }
    transformFilter(node) {
        return {
            kind: 'FilterNode',
            left: this.transformNode(node.left),
            op: this.transformNode(node.op),
            right: this.transformNode(node.right),
        };
    }
    transformAnd(node) {
        return {
            kind: 'AndNode',
            left: this.transformNode(node.left),
            right: this.transformNode(node.right),
        };
    }
    transformOr(node) {
        return {
            kind: 'OrNode',
            left: this.transformNode(node.left),
            right: this.transformNode(node.right),
        };
    }
    transformValueList(node) {
        return {
            kind: 'ValueListNode',
            values: this.transformNodeList(node.values),
        };
    }
    transformParens(node) {
        return {
            kind: 'ParensNode',
            node: this.transformNode(node.node),
        };
    }
    transformJoin(node) {
        return {
            kind: 'JoinNode',
            joinType: node.joinType,
            table: this.transformNode(node.table),
            on: this.transformNode(node.on),
        };
    }
    transformRaw(node) {
        return {
            kind: 'RawNode',
            sqlFragments: freeze([...node.sqlFragments]),
            params: this.transformNodeList(node.params),
        };
    }
    transformWhere(node) {
        return {
            kind: 'WhereNode',
            where: this.transformNode(node.where),
        };
    }
    transformInsertQuery(node) {
        return {
            kind: 'InsertQueryNode',
            into: this.transformNode(node.into),
            columns: this.transformNodeList(node.columns),
            values: this.transformNode(node.values),
            returning: this.transformNode(node.returning),
            onConflict: this.transformNode(node.onConflict),
            onDuplicateKey: this.transformNode(node.onDuplicateKey),
            with: this.transformNode(node.with),
            ignore: node.ignore,
        };
    }
    transformValues(node) {
        return {
            kind: 'ValuesNode',
            values: this.transformNodeList(node.values),
        };
    }
    transformDeleteQuery(node) {
        return {
            kind: 'DeleteQueryNode',
            from: this.transformNode(node.from),
            joins: this.transformNodeList(node.joins),
            where: this.transformNode(node.where),
            returning: this.transformNode(node.returning),
            with: this.transformNode(node.with),
        };
    }
    transformReturning(node) {
        return {
            kind: 'ReturningNode',
            selections: this.transformNodeList(node.selections),
        };
    }
    transformCreateTable(node) {
        return {
            kind: 'CreateTableNode',
            table: this.transformNode(node.table),
            columns: this.transformNodeList(node.columns),
            constraints: this.transformNodeList(node.constraints),
            temporary: node.temporary,
            ifNotExists: node.ifNotExists,
            onCommit: node.onCommit,
        };
    }
    transformColumnDefinition(node) {
        return {
            kind: 'ColumnDefinitionNode',
            column: this.transformNode(node.column),
            dataType: this.transformNode(node.dataType),
            references: this.transformNode(node.references),
            primaryKey: node.primaryKey,
            autoIncrement: node.autoIncrement,
            unique: node.unique,
            notNull: node.notNull,
            unsigned: node.unsigned,
            defaultTo: this.transformNode(node.defaultTo),
            check: this.transformNode(node.check),
            generated: this.transformNode(node.generated),
        };
    }
    transformAddColumn(node) {
        return {
            kind: 'AddColumnNode',
            column: this.transformNode(node.column),
        };
    }
    transformDropTable(node) {
        return {
            kind: 'DropTableNode',
            table: this.transformNode(node.table),
            ifExists: node.ifExists,
        };
    }
    transformOrderBy(node) {
        return {
            kind: 'OrderByNode',
            items: this.transformNodeList(node.items),
        };
    }
    transformOrderByItem(node) {
        return {
            kind: 'OrderByItemNode',
            orderBy: this.transformNode(node.orderBy),
            direction: this.transformNode(node.direction),
        };
    }
    transformGroupBy(node) {
        return {
            kind: 'GroupByNode',
            items: this.transformNodeList(node.items),
        };
    }
    transformGroupByItem(node) {
        return {
            kind: 'GroupByItemNode',
            groupBy: this.transformNode(node.groupBy),
        };
    }
    transformUpdateQuery(node) {
        return {
            kind: 'UpdateQueryNode',
            table: this.transformNode(node.table),
            joins: this.transformNodeList(node.joins),
            where: this.transformNode(node.where),
            updates: this.transformNodeList(node.updates),
            returning: this.transformNode(node.returning),
            with: this.transformNode(node.with),
        };
    }
    transformColumnUpdate(node) {
        return {
            kind: 'ColumnUpdateNode',
            column: this.transformNode(node.column),
            value: this.transformNode(node.value),
        };
    }
    transformLimit(node) {
        return {
            kind: 'LimitNode',
            limit: this.transformNode(node.limit),
        };
    }
    transformOffset(node) {
        return {
            kind: 'OffsetNode',
            offset: this.transformNode(node.offset),
        };
    }
    transformOnConflict(node) {
        return {
            kind: 'OnConflictNode',
            columns: this.transformNodeList(node.columns),
            constraint: this.transformNode(node.constraint),
            indexExpression: this.transformNode(node.indexExpression),
            indexWhere: this.transformNode(node.indexWhere),
            updates: this.transformNodeList(node.updates),
            updateWhere: this.transformNode(node.updateWhere),
            doNothing: node.doNothing,
        };
    }
    transformOnDuplicateKey(node) {
        return {
            kind: 'OnDuplicateKeyNode',
            updates: this.transformNodeList(node.updates),
        };
    }
    transformCreateIndex(node) {
        return {
            kind: 'CreateIndexNode',
            name: this.transformNode(node.name),
            table: this.transformNode(node.table),
            expression: this.transformNode(node.expression),
            unique: node.unique,
            using: this.transformNode(node.using),
        };
    }
    transformList(node) {
        return {
            kind: 'ListNode',
            items: this.transformNodeList(node.items),
        };
    }
    transformDropIndex(node) {
        return {
            kind: 'DropIndexNode',
            name: this.transformNode(node.name),
            table: this.transformNode(node.table),
            ifExists: node.ifExists,
        };
    }
    transformPrimaryKeyConstraint(node) {
        return {
            kind: 'PrimaryKeyConstraintNode',
            columns: this.transformNodeList(node.columns),
            name: this.transformNode(node.name),
        };
    }
    transformUniqueConstraint(node) {
        return {
            kind: 'UniqueConstraintNode',
            columns: this.transformNodeList(node.columns),
            name: this.transformNode(node.name),
        };
    }
    transformForeignKeyConstraint(node) {
        return {
            kind: 'ForeignKeyConstraintNode',
            columns: this.transformNodeList(node.columns),
            references: this.transformNode(node.references),
            name: this.transformNode(node.name),
            onDelete: node.onDelete,
            onUpdate: node.onUpdate,
        };
    }
    transformUnion(node) {
        return {
            kind: 'UnionNode',
            union: this.transformNode(node.union),
            all: node.all,
        };
    }
    transformReferences(node) {
        return {
            kind: 'ReferencesNode',
            table: this.transformNode(node.table),
            columns: this.transformNodeList(node.columns),
            onDelete: node.onDelete,
            onUpdate: node.onUpdate,
        };
    }
    transformCheckConstraint(node) {
        return {
            kind: 'CheckConstraintNode',
            expression: this.transformNode(node.expression),
            name: this.transformNode(node.name),
        };
    }
    transformWith(node) {
        return {
            kind: 'WithNode',
            expressions: this.transformNodeList(node.expressions),
            recursive: node.recursive,
        };
    }
    transformCommonTableExpression(node) {
        return {
            kind: 'CommonTableExpressionNode',
            name: this.transformNode(node.name),
            expression: this.transformNode(node.expression),
        };
    }
    transformCommonTableExpressionName(node) {
        return {
            kind: 'CommonTableExpressionNameNode',
            table: this.transformNode(node.table),
            columns: this.transformNodeList(node.columns),
        };
    }
    transformHaving(node) {
        return {
            kind: 'HavingNode',
            having: this.transformNode(node.having),
        };
    }
    transformCreateSchema(node) {
        return {
            kind: 'CreateSchemaNode',
            schema: this.transformNode(node.schema),
        };
    }
    transformDropSchema(node) {
        return {
            kind: 'DropSchemaNode',
            schema: this.transformNode(node.schema),
            ifExists: node.ifExists,
        };
    }
    transformAlterTable(node) {
        return {
            kind: 'AlterTableNode',
            table: this.transformNode(node.table),
            renameTo: this.transformNode(node.renameTo),
            setSchema: this.transformNode(node.setSchema),
            renameColumn: this.transformNode(node.renameColumn),
            addColumn: this.transformNode(node.addColumn),
            dropColumn: this.transformNode(node.dropColumn),
            alterColumn: this.transformNode(node.alterColumn),
            modifyColumn: this.transformNode(node.modifyColumn),
            addConstraint: this.transformNode(node.addConstraint),
            dropConstraint: this.transformNode(node.dropConstraint),
        };
    }
    transformDropColumn(node) {
        return {
            kind: 'DropColumnNode',
            column: this.transformNode(node.column),
        };
    }
    transformRenameColumn(node) {
        return {
            kind: 'RenameColumnNode',
            column: this.transformNode(node.column),
            renameTo: this.transformNode(node.renameTo),
        };
    }
    transformAlterColumn(node) {
        return {
            kind: 'AlterColumnNode',
            column: this.transformNode(node.column),
            dataType: this.transformNode(node.dataType),
            dataTypeExpression: this.transformNode(node.dataTypeExpression),
            setDefault: this.transformNode(node.setDefault),
            dropDefault: node.dropDefault,
            setNotNull: node.setNotNull,
            dropNotNull: node.dropNotNull,
        };
    }
    transformModifyColumn(node) {
        return {
            kind: 'ModifyColumnNode',
            column: this.transformNode(node.column),
        };
    }
    transformAddConstraint(node) {
        return {
            kind: 'AddConstraintNode',
            constraint: this.transformNode(node.constraint),
        };
    }
    transformDropConstraint(node) {
        return {
            kind: 'DropConstraintNode',
            constraintName: this.transformNode(node.constraintName),
        };
    }
    transformCreateView(node) {
        return {
            kind: 'CreateViewNode',
            name: this.transformNode(node.name),
            temporary: node.temporary,
            orReplace: node.orReplace,
            ifNotExists: node.ifNotExists,
            materialized: node.materialized,
            columns: this.transformNodeList(node.columns),
            as: this.transformNode(node.as),
        };
    }
    transformDropView(node) {
        return {
            kind: 'DropViewNode',
            name: this.transformNode(node.name),
            ifExists: node.ifExists,
            materialized: node.materialized,
        };
    }
    transformGenerated(node) {
        return {
            kind: 'GeneratedNode',
            byDefault: node.byDefault,
            always: node.always,
            identity: node.identity,
            stored: node.stored,
            expression: this.transformNode(node.expression),
        };
    }
    transformDefaultValue(node) {
        return {
            kind: 'DefaultValueNode',
            defaultValue: this.transformNode(node.defaultValue),
        };
    }
    transformOn(node) {
        return {
            kind: 'OnNode',
            on: this.transformNode(node.on),
        };
    }
    transformDataType(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformSelectAll(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformIdentifier(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformValue(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformPrimitiveValueList(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformOperator(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
}
