/// <reference types="./raw-builder.d.ts" />
import { AliasNode } from '../operation-node/alias-node.js';
import { isOperationNodeSource, } from '../operation-node/operation-node-source.js';
import { RawNode } from '../operation-node/raw-node.js';
import { ValueNode } from '../operation-node/value-node.js';
import { parseStringReference } from '../parser/reference-parser.js';
import { preventAwait } from '../util/prevent-await.js';
import { createQueryId } from '../util/query-id.js';
import { freeze } from '../util/object-utils.js';
import { NoopQueryExecutor } from '../query-executor/noop-query-executor.js';
export class RawBuilder {
    #props;
    constructor(props) {
        this.#props = freeze({
            queryId: props.queryId ?? createQueryId(),
            executor: props.executor ?? new NoopQueryExecutor(),
            sql: props.sql,
            parameters: props.parameters,
        });
    }
    as(alias) {
        return new AliasedRawBuilder(this, alias);
    }
    /**
     * Change the output type of the raw expression.
     *
     * This doesn't produce any SQL. This methods simply returns a copy
     * of this `RawBuilder` with a new output type.
     */
    castTo() {
        return new RawBuilder({
            ...this.#props,
        });
    }
    withPlugin(plugin) {
        return new RawBuilder({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    toOperationNode() {
        const parameterPlaceholderRegex = /(\?\??)/g;
        const sql = this.#props.sql;
        const parameters = this.#props.parameters ?? [];
        const sqlFragments = [];
        const argNodes = [];
        let paramIdx = 0;
        let sqlIdx = 0;
        let match = null;
        while ((match = parameterPlaceholderRegex.exec(sql))) {
            const str = match[1];
            if (paramIdx >= parameters.length) {
                throw new Error(`value not provided for all placeholders in string ${sql}`);
            }
            if (match.index > 0 && sql[match.index - 1] === '\\') {
                continue;
            }
            sqlFragments.push(sql.slice(sqlIdx, match.index).replace(/\\\?/g, '?'));
            argNodes.push(parseRawArg(str, parameters[paramIdx]));
            sqlIdx = match.index + str.length;
            ++paramIdx;
        }
        sqlFragments.push(sql.slice(sqlIdx));
        const rawNode = RawNode.create(sqlFragments, argNodes);
        return this.#props.executor.transformQuery(rawNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        return this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(RawBuilder, "don't await RawBuilder instances directly. To execute the query you need to call `execute`");
/**
 * {@link RawBuilder} with an alias. The result of calling {@link RawBuilder.as}.
 */
export class AliasedRawBuilder {
    #rawBuilder;
    #alias;
    /**
     * @private
     *
     * This needs to be here just so that the typings work. Without this
     * the generated .d.ts file contains no reference to the type param A
     * which causes this type to be equal to AliasedRawBuilder with any A
     * as long as O is the same.
     */
    get alias() {
        return this.#alias;
    }
    toOperationNode() {
        return AliasNode.create(this.#rawBuilder.toOperationNode(), this.#alias);
    }
    constructor(rawBuilder, alias) {
        this.#rawBuilder = rawBuilder;
        this.#alias = alias;
    }
}
function parseRawArg(match, arg) {
    if (isOperationNodeSource(arg)) {
        return arg.toOperationNode();
    }
    else if (match === '??') {
        return parseStringReference(arg);
    }
    else {
        return ValueNode.create(arg);
    }
}
