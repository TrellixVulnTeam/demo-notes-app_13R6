/// <reference types="./sqlite-driver.d.ts" />
import { CompiledQuery } from '../../query-compiler/compiled-query.js';
import { freeze, isBoolean, isFunction, isNumber, } from '../../util/object-utils.js';
export class SqliteDriver {
    #config;
    #connectionMutex = new ConnectionMutex();
    #db;
    #connection;
    constructor(config) {
        this.#config = freeze({ ...config });
    }
    async init() {
        // Import the `better-sqlite3` module here instead at the top of the file
        // so that this file can be loaded by node without `better-sqlite3` driver
        // installed. As you can see, there IS an import from `better-sqlite3` at
        // the top level too, but that's only for types. It doesn't get compiled
        // into javascript. You can check the built javascript code.
        const DatabaseConstructor = await importBetterSqlite3Database();
        const options = {};
        if (isBoolean(this.#config.readonly)) {
            options.readonly = this.#config.readonly;
        }
        if (isBoolean(this.#config.fileMustExist)) {
            options.fileMustExist = this.#config.fileMustExist;
        }
        if (isNumber(this.#config.timeout)) {
            options.timeout = this.#config.timeout;
        }
        if (isFunction(this.#config.verbose)) {
            options.verbose = this.#config.verbose;
        }
        this.#db = new DatabaseConstructor(this.#config.databasePath, options);
        this.#connection = new SqliteConnection(this.#db);
        if (this.#config.onCreateConnection) {
            await this.#config.onCreateConnection(this.#connection);
        }
    }
    async acquireConnection() {
        // SQLite only has one single connection. We use a mutex here to wait
        // until the single connection has been released.
        await this.#connectionMutex.lock();
        return this.#connection;
    }
    async beginTransaction(connection) {
        await connection.executeQuery(CompiledQuery.raw('begin'));
    }
    async commitTransaction(connection) {
        await connection.executeQuery(CompiledQuery.raw('commit'));
    }
    async rollbackTransaction(connection) {
        await connection.executeQuery(CompiledQuery.raw('rollback'));
    }
    async releaseConnection() {
        this.#connectionMutex.unlock();
    }
    async destroy() {
        this.#db?.close();
    }
}
async function importBetterSqlite3Database() {
    try {
        // The imported module name must be a string literal to make
        // some bundlers work. So don't move this code behind a helper
        // for example.
        const sqliteModule = await import('better-sqlite3');
        if (isFunction(sqliteModule)) {
            return sqliteModule;
        }
        else {
            return sqliteModule.default;
        }
    }
    catch (error) {
        throw new Error('SQLite client not installed. Please run `npm install better-sqlite3`');
    }
}
class SqliteConnection {
    #db;
    constructor(db) {
        this.#db = db;
    }
    executeQuery(compiledQuery) {
        const { sql, parameters } = compiledQuery;
        const stmt = this.#db.prepare(sql);
        if (stmt.reader) {
            return Promise.resolve({
                rows: stmt.all(parameters),
            });
        }
        else {
            const { changes, lastInsertRowid } = stmt.run(parameters);
            return Promise.resolve({
                numUpdatedOrDeletedRows: changes !== undefined && changes !== null
                    ? BigInt(changes)
                    : undefined,
                insertId: lastInsertRowid !== undefined && lastInsertRowid !== null
                    ? BigInt(lastInsertRowid)
                    : undefined,
                rows: [],
            });
        }
    }
}
class ConnectionMutex {
    #promise;
    #resolve;
    async lock() {
        while (this.#promise) {
            await this.#promise;
        }
        this.#promise = new Promise((resolve) => {
            this.#resolve = resolve;
        });
    }
    unlock() {
        const resolve = this.#resolve;
        this.#promise = undefined;
        this.#resolve = undefined;
        resolve?.();
    }
}
