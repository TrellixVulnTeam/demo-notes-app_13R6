"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFilter = exports.parseNotExistFilter = exports.parseExistFilter = exports.parseReferenceFilter = exports.parseOnFilter = exports.parseHavingFilter = exports.parseWhereFilter = void 0;
const filter_node_js_1 = require("../operation-node/filter-node.js");
const object_utils_js_1 = require("../util/object-utils.js");
const operation_node_source_js_1 = require("../operation-node/operation-node-source.js");
const raw_node_js_1 = require("../operation-node/raw-node.js");
const operator_node_js_1 = require("../operation-node/operator-node.js");
const parens_node_js_1 = require("../operation-node/parens-node.js");
const reference_parser_js_1 = require("./reference-parser.js");
const value_parser_js_1 = require("./value-parser.js");
const value_node_js_1 = require("../operation-node/value-node.js");
function parseWhereFilter(ctx, args) {
    return parseFilter(ctx, 'where', args);
}
exports.parseWhereFilter = parseWhereFilter;
function parseHavingFilter(ctx, args) {
    return parseFilter(ctx, 'having', args);
}
exports.parseHavingFilter = parseHavingFilter;
function parseOnFilter(ctx, args) {
    return parseFilter(ctx, 'on', args);
}
exports.parseOnFilter = parseOnFilter;
function parseReferenceFilter(ctx, lhs, op, rhs) {
    return filter_node_js_1.FilterNode.create((0, reference_parser_js_1.parseReferenceExpression)(ctx, lhs), parseFilterOperator(op), (0, reference_parser_js_1.parseReferenceExpression)(ctx, rhs));
}
exports.parseReferenceFilter = parseReferenceFilter;
function parseExistFilter(ctx, arg) {
    return parseExistExpression(ctx, 'exists', arg);
}
exports.parseExistFilter = parseExistFilter;
function parseNotExistFilter(ctx, arg) {
    return parseExistExpression(ctx, 'not exists', arg);
}
exports.parseNotExistFilter = parseNotExistFilter;
function parseFilter(ctx, type, args) {
    if (args.length === 3) {
        return parseThreeArgFilter(ctx, args[0], args[1], args[2]);
    }
    else if (args.length === 1) {
        return parseOneArgFilter(ctx, type, args[0]);
    }
    throw createFilterError(type, args);
}
exports.parseFilter = parseFilter;
function parseThreeArgFilter(ctx, left, op, right) {
    if ((op === 'is' || op === 'is not') && ((0, object_utils_js_1.isNull)(right) || (0, object_utils_js_1.isBoolean)(right))) {
        return parseIsFilter(ctx, left, op, right);
    }
    return filter_node_js_1.FilterNode.create((0, reference_parser_js_1.parseReferenceExpression)(ctx, left), parseFilterOperator(op), (0, value_parser_js_1.parseValueExpressionOrList)(ctx, right));
}
function parseIsFilter(ctx, left, op, right) {
    return filter_node_js_1.FilterNode.create((0, reference_parser_js_1.parseReferenceExpression)(ctx, left), parseFilterOperator(op), value_node_js_1.ValueNode.createImmediate(right));
}
function parseFilterOperator(op) {
    if ((0, object_utils_js_1.isString)(op) && operator_node_js_1.OPERATORS.includes(op)) {
        return operator_node_js_1.OperatorNode.create(op);
    }
    else if ((0, operation_node_source_js_1.isOperationNodeSource)(op)) {
        return op.toOperationNode();
    }
    throw new Error(`invalid comparison operator ${JSON.stringify(op)} passed to a filter method`);
}
function parseExistExpression(ctx, type, arg) {
    return filter_node_js_1.FilterNode.create(undefined, operator_node_js_1.OperatorNode.create(type), (0, value_parser_js_1.parseValueExpressionOrList)(ctx, arg));
}
function parseOneArgFilter(ctx, type, arg) {
    if ((0, object_utils_js_1.isFunction)(arg)) {
        return GROUP_PARSERS[type](ctx, arg);
    }
    else if ((0, operation_node_source_js_1.isOperationNodeSource)(arg)) {
        const node = arg.toOperationNode();
        if (raw_node_js_1.RawNode.is(node)) {
            return node;
        }
    }
    throw createFilterError(type, arg);
}
function createFilterError(type, args) {
    return new Error(`invalid arguments passed to a '${type}' method: ${JSON.stringify(args)}`);
}
const GROUP_PARSERS = (0, object_utils_js_1.freeze)({
    where(ctx, callback) {
        const query = callback(ctx.createSelectQueryBuilder());
        const queryNode = query.toOperationNode();
        if (!queryNode.where) {
            throw new Error('no `where` methods called insided a group callback');
        }
        return parens_node_js_1.ParensNode.create(queryNode.where.where);
    },
    having(ctx, callback) {
        const query = callback(ctx.createSelectQueryBuilder());
        const queryNode = query.toOperationNode();
        if (!queryNode.having) {
            throw new Error('no `having` methods called insided a group callback');
        }
        return parens_node_js_1.ParensNode.create(queryNode.having.having);
    },
    on(ctx, callback) {
        const joinBuilder = callback(ctx.createJoinBuilder('InnerJoin', 'table'));
        const joinNode = joinBuilder.toOperationNode();
        if (!joinNode.on) {
            throw new Error('no `on` methods called insided a group callback');
        }
        return parens_node_js_1.ParensNode.create(joinNode.on.on);
    },
});
