"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AliasedRawBuilder = exports.RawBuilder = void 0;
const alias_node_js_1 = require("../operation-node/alias-node.js");
const operation_node_source_js_1 = require("../operation-node/operation-node-source.js");
const raw_node_js_1 = require("../operation-node/raw-node.js");
const value_node_js_1 = require("../operation-node/value-node.js");
const reference_parser_js_1 = require("../parser/reference-parser.js");
const prevent_await_js_1 = require("../util/prevent-await.js");
const query_id_js_1 = require("../util/query-id.js");
const object_utils_js_1 = require("../util/object-utils.js");
const noop_query_executor_js_1 = require("../query-executor/noop-query-executor.js");
class RawBuilder {
    #props;
    constructor(props) {
        this.#props = (0, object_utils_js_1.freeze)({
            queryId: props.queryId ?? (0, query_id_js_1.createQueryId)(),
            executor: props.executor ?? new noop_query_executor_js_1.NoopQueryExecutor(),
            sql: props.sql,
            parameters: props.parameters,
        });
    }
    as(alias) {
        return new AliasedRawBuilder(this, alias);
    }
    /**
     * Change the output type of the raw expression.
     *
     * This doesn't produce any SQL. This methods simply returns a copy
     * of this `RawBuilder` with a new output type.
     */
    castTo() {
        return new RawBuilder({
            ...this.#props,
        });
    }
    withPlugin(plugin) {
        return new RawBuilder({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    toOperationNode() {
        const parameterPlaceholderRegex = /(\?\??)/g;
        const sql = this.#props.sql;
        const parameters = this.#props.parameters ?? [];
        const sqlFragments = [];
        const argNodes = [];
        let paramIdx = 0;
        let sqlIdx = 0;
        let match = null;
        while ((match = parameterPlaceholderRegex.exec(sql))) {
            const str = match[1];
            if (paramIdx >= parameters.length) {
                throw new Error(`value not provided for all placeholders in string ${sql}`);
            }
            if (match.index > 0 && sql[match.index - 1] === '\\') {
                continue;
            }
            sqlFragments.push(sql.slice(sqlIdx, match.index).replace(/\\\?/g, '?'));
            argNodes.push(parseRawArg(str, parameters[paramIdx]));
            sqlIdx = match.index + str.length;
            ++paramIdx;
        }
        sqlFragments.push(sql.slice(sqlIdx));
        const rawNode = raw_node_js_1.RawNode.create(sqlFragments, argNodes);
        return this.#props.executor.transformQuery(rawNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        return this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
exports.RawBuilder = RawBuilder;
(0, prevent_await_js_1.preventAwait)(RawBuilder, "don't await RawBuilder instances directly. To execute the query you need to call `execute`");
/**
 * {@link RawBuilder} with an alias. The result of calling {@link RawBuilder.as}.
 */
class AliasedRawBuilder {
    #rawBuilder;
    #alias;
    /**
     * @private
     *
     * This needs to be here just so that the typings work. Without this
     * the generated .d.ts file contains no reference to the type param A
     * which causes this type to be equal to AliasedRawBuilder with any A
     * as long as O is the same.
     */
    get alias() {
        return this.#alias;
    }
    toOperationNode() {
        return alias_node_js_1.AliasNode.create(this.#rawBuilder.toOperationNode(), this.#alias);
    }
    constructor(rawBuilder, alias) {
        this.#rawBuilder = rawBuilder;
        this.#alias = alias;
    }
}
exports.AliasedRawBuilder = AliasedRawBuilder;
function parseRawArg(match, arg) {
    if ((0, operation_node_source_js_1.isOperationNodeSource)(arg)) {
        return arg.toOperationNode();
    }
    else if (match === '??') {
        return (0, reference_parser_js_1.parseStringReference)(arg);
    }
    else {
        return value_node_js_1.ValueNode.create(arg);
    }
}
