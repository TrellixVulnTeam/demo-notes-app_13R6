import { QueryResult } from '../driver/database-connection.js';
import { AliasNode } from '../operation-node/alias-node.js';
import { OperationNodeSource } from '../operation-node/operation-node-source.js';
import { RawNode } from '../operation-node/raw-node.js';
import { CompiledQuery } from '../query-compiler/compiled-query.js';
import { QueryExecutor } from '../query-executor/query-executor.js';
import { QueryId } from '../util/query-id.js';
import { KyselyPlugin } from '../plugin/kysely-plugin.js';
export declare class RawBuilder<O = unknown> implements OperationNodeSource {
    #private;
    constructor(props: RawBuilderProps);
    as<A extends string>(alias: A): AliasedRawBuilder<O, A>;
    /**
     * Change the output type of the raw expression.
     *
     * This doesn't produce any SQL. This methods simply returns a copy
     * of this `RawBuilder` with a new output type.
     */
    castTo<T>(): RawBuilder<T>;
    withPlugin(plugin: KyselyPlugin): RawBuilder<O>;
    toOperationNode(): RawNode;
    compile(): CompiledQuery;
    execute(): Promise<QueryResult<O>>;
}
/**
 * {@link RawBuilder} with an alias. The result of calling {@link RawBuilder.as}.
 */
export declare class AliasedRawBuilder<O = unknown, A extends string = never> implements OperationNodeSource {
    #private;
    /**
     * @private
     *
     * This needs to be here just so that the typings work. Without this
     * the generated .d.ts file contains no reference to the type param A
     * which causes this type to be equal to AliasedRawBuilder with any A
     * as long as O is the same.
     */
    protected get alias(): A;
    toOperationNode(): AliasNode;
    constructor(rawBuilder: RawBuilder<O>, alias: A);
}
export interface RawBuilderProps {
    readonly queryId?: QueryId;
    readonly executor?: QueryExecutor;
    readonly sql: string;
    readonly parameters?: ReadonlyArray<unknown>;
}
