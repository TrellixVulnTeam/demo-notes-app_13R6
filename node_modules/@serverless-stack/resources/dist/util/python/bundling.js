"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stageDependencies = exports.bundle = exports.BUNDLER_DEPENDENCIES_CACHE = exports.DEPENDENCY_EXCLUDES = void 0;
/**
 * This file is copied from https://github.com/aws/aws-cdk/blob/master/packages/@aws-cdk/aws-lambda-python/lib/bundling.ts
 */
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const cdk = __importStar(require("aws-cdk-lib"));
const lambda = __importStar(require("aws-cdk-lib/aws-lambda"));
/**
 * Dependency files to exclude from the asset hash.
 */
exports.DEPENDENCY_EXCLUDES = ["*.pyc"];
/**
 * The location in the image that the bundler image caches dependencies.
 */
exports.BUNDLER_DEPENDENCIES_CACHE = "/var/dependencies";
/**
 * Produce bundled Lambda asset code
 */
function bundle(options) {
    const { entry, runtime, outputPathSuffix, installCommands } = options;
    const stagedir = cdk.FileSystem.mkdtemp("python-bundling-");
    const hasDeps = stageDependencies(entry, stagedir);
    const hasInstallCommands = stageInstallCommands(installCommands || [], stagedir);
    const depsCommand = chain([
        hasDeps || hasInstallCommands
            ? `rsync -r ${exports.BUNDLER_DEPENDENCIES_CACHE}/. ${cdk.AssetStaging.BUNDLING_OUTPUT_DIR}/${outputPathSuffix}`
            : "",
        `rsync -r . ${cdk.AssetStaging.BUNDLING_OUTPUT_DIR}/${outputPathSuffix}`,
    ]);
    // Determine which dockerfile to use. When dependencies are present, we use a
    // Dockerfile that can create a cacheable layer. We can't use this Dockerfile
    // if there aren't dependencies or the Dockerfile will complain about missing
    // sources.
    const dockerfile = hasInstallCommands
        ? "Dockerfile.custom"
        : hasDeps
            ? "Dockerfile.dependencies"
            : "Dockerfile";
    // copy Dockerfile to workdir
    fs.copyFileSync(path.join(__dirname, "../../../assets/python", dockerfile), path.join(stagedir, dockerfile));
    const image = cdk.DockerImage.fromBuild(stagedir, {
        buildArgs: {
            IMAGE: runtime.bundlingImage.image,
        },
        file: dockerfile,
    });
    return lambda.Code.fromAsset(entry, {
        assetHashType: options.assetHashType,
        assetHash: options.assetHash,
        exclude: exports.DEPENDENCY_EXCLUDES,
        bundling: {
            image,
            command: ["bash", "-c", depsCommand],
        },
    });
}
exports.bundle = bundle;
/**
 * Checks to see if the `entry` directory contains a type of dependency that
 * we know how to install.
 */
function stageDependencies(entry, stagedir) {
    const prefixes = ["Pipfile", "pyproject", "poetry", "requirements.txt"];
    let found = false;
    for (const file of fs.readdirSync(entry)) {
        for (const prefix of prefixes) {
            if (file.startsWith(prefix)) {
                fs.copyFileSync(path.join(entry, file), path.join(stagedir, file));
                found = true;
            }
        }
    }
    return found;
}
exports.stageDependencies = stageDependencies;
function stageInstallCommands(installCommands, stagedir) {
    let found = false;
    if (installCommands.length > 0) {
        const filePath = path.join(stagedir, "sst-deps-install-command.sh");
        fs.writeFileSync(filePath, installCommands.join(" && "));
        fs.chmodSync(filePath, "755");
        found = true;
    }
    return found;
}
function chain(commands) {
    return commands.filter((c) => !!c).join(" && ");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbC9weXRob24vYnVuZGxpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILHVDQUF5QjtBQUN6QiwyQ0FBNkI7QUFDN0IsaURBQW1DO0FBQ25DLCtEQUFpRDtBQUVqRDs7R0FFRztBQUNVLFFBQUEsbUJBQW1CLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUU3Qzs7R0FFRztBQUNVLFFBQUEsMEJBQTBCLEdBQUcsbUJBQW1CLENBQUM7QUFnRTlEOztHQUVHO0FBQ0gsU0FBZ0IsTUFBTSxDQUFDLE9BQXdCO0lBQzdDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBRSxHQUFHLE9BQU8sQ0FBQztJQUV0RSxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQzVELE1BQU0sT0FBTyxHQUFHLGlCQUFpQixDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNuRCxNQUFNLGtCQUFrQixHQUFHLG9CQUFvQixDQUM3QyxlQUFlLElBQUksRUFBRSxFQUNyQixRQUFRLENBQ1QsQ0FBQztJQUVGLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN4QixPQUFPLElBQUksa0JBQWtCO1lBQzNCLENBQUMsQ0FBQyxZQUFZLGtDQUEwQixNQUFNLEdBQUcsQ0FBQyxZQUFZLENBQUMsbUJBQW1CLElBQUksZ0JBQWdCLEVBQUU7WUFDeEcsQ0FBQyxDQUFDLEVBQUU7UUFDTixjQUFjLEdBQUcsQ0FBQyxZQUFZLENBQUMsbUJBQW1CLElBQUksZ0JBQWdCLEVBQUU7S0FDekUsQ0FBQyxDQUFDO0lBRUgsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsV0FBVztJQUNYLE1BQU0sVUFBVSxHQUFHLGtCQUFrQjtRQUNuQyxDQUFDLENBQUMsbUJBQW1CO1FBQ3JCLENBQUMsQ0FBQyxPQUFPO1lBQ1QsQ0FBQyxDQUFDLHlCQUF5QjtZQUMzQixDQUFDLENBQUMsWUFBWSxDQUFDO0lBRWpCLDZCQUE2QjtJQUM3QixFQUFFLENBQUMsWUFBWSxDQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLHdCQUF3QixFQUFFLFVBQVUsQ0FBQyxFQUMxRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FDaEMsQ0FBQztJQUVGLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRTtRQUNoRCxTQUFTLEVBQUU7WUFDVCxLQUFLLEVBQUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLO1NBQ25DO1FBQ0QsSUFBSSxFQUFFLFVBQVU7S0FDakIsQ0FBQyxDQUFDO0lBRUgsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUU7UUFDbEMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxhQUFhO1FBQ3BDLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUztRQUM1QixPQUFPLEVBQUUsMkJBQW1CO1FBQzVCLFFBQVEsRUFBRTtZQUNSLEtBQUs7WUFDTCxPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQztTQUNyQztLQUNGLENBQUMsQ0FBQztBQUNMLENBQUM7QUFqREQsd0JBaURDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsS0FBYSxFQUFFLFFBQWdCO0lBQy9ELE1BQU0sUUFBUSxHQUFHLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUV4RSxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDbEIsS0FBSyxNQUFNLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3hDLEtBQUssTUFBTSxNQUFNLElBQUksUUFBUSxFQUFFO1lBQzdCLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDM0IsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxLQUFLLEdBQUcsSUFBSSxDQUFDO2FBQ2Q7U0FDRjtLQUNGO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBZEQsOENBY0M7QUFFRCxTQUFTLG9CQUFvQixDQUMzQixlQUF5QixFQUN6QixRQUFnQjtJQUVoQixJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDbEIsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUM5QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSw2QkFBNkIsQ0FBQyxDQUFDO1FBQ3BFLEVBQUUsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN6RCxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM5QixLQUFLLEdBQUcsSUFBSSxDQUFDO0tBQ2Q7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFFRCxTQUFTLEtBQUssQ0FBQyxRQUFrQjtJQUMvQixPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIGlzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9ibG9iL21hc3Rlci9wYWNrYWdlcy9AYXdzLWNkay9hd3MtbGFtYmRhLXB5dGhvbi9saWIvYnVuZGxpbmcudHNcbiAqL1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBjZGsgZnJvbSBcImF3cy1jZGstbGliXCI7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSBcImF3cy1jZGstbGliL2F3cy1sYW1iZGFcIjtcblxuLyoqXG4gKiBEZXBlbmRlbmN5IGZpbGVzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgYXNzZXQgaGFzaC5cbiAqL1xuZXhwb3J0IGNvbnN0IERFUEVOREVOQ1lfRVhDTFVERVMgPSBbXCIqLnB5Y1wiXTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gaW4gdGhlIGltYWdlIHRoYXQgdGhlIGJ1bmRsZXIgaW1hZ2UgY2FjaGVzIGRlcGVuZGVuY2llcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEJVTkRMRVJfREVQRU5ERU5DSUVTX0NBQ0hFID0gXCIvdmFyL2RlcGVuZGVuY2llc1wiO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGJ1bmRsaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnVuZGxpbmdPcHRpb25zIHtcbiAgLyoqXG4gICAqIEVudHJ5IHBhdGhcbiAgICovXG4gIHJlYWRvbmx5IGVudHJ5OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBydW50aW1lIG9mIHRoZSBsYW1iZGEgZnVuY3Rpb25cbiAgICovXG4gIHJlYWRvbmx5IHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lO1xuXG4gIC8qKlxuICAgKiBPdXRwdXQgcGF0aCBzdWZmaXggKCdweXRob24nIGZvciBhIGxheWVyLCAnLicgb3RoZXJ3aXNlKVxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UGF0aFN1ZmZpeDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGhvdyBhc3NldCBoYXNoIGlzIGNhbGN1bGF0ZWQuIEFzc2V0cyB3aWxsIGdldCByZWJ1aWxkIGFuZFxuICAgKiB1cGxvYWRlZCBvbmx5IGlmIHRoZWlyIGhhc2ggaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIElmIGFzc2V0IGhhc2ggaXMgc2V0IHRvIGBTT1VSQ0VgIChkZWZhdWx0KSwgdGhlbiBvbmx5IGNoYW5nZXMgdG8gdGhlIHNvdXJjZVxuICAgKiBkaXJlY3Rvcnkgd2lsbCBjYXVzZSB0aGUgYXNzZXQgdG8gcmVidWlsZC4gVGhpcyBtZWFucywgZm9yIGV4YW1wbGUsIHRoYXQgaW5cbiAgICogb3JkZXIgdG8gcGljayB1cCBhIG5ldyBkZXBlbmRlbmN5IHZlcnNpb24sIGEgY2hhbmdlIG11c3QgYmUgbWFkZSB0byB0aGVcbiAgICogc291cmNlIHRyZWUuIElkZWFsbHksIHRoaXMgY2FuIGJlIGltcGxlbWVudGVkIGJ5IGluY2x1ZGluZyBhIGRlcGVuZGVuY3lcbiAgICogbG9ja2ZpbGUgaW4geW91ciBzb3VyY2UgdHJlZSBvciB1c2luZyBmaXhlZCBkZXBlbmRlbmNpZXMuXG4gICAqXG4gICAqIElmIHRoZSBhc3NldCBoYXNoIGlzIHNldCB0byBgT1VUUFVUYCwgdGhlIGhhc2ggaXMgY2FsY3VsYXRlZCBhZnRlclxuICAgKiBidW5kbGluZy4gVGhpcyBtZWFucyB0aGF0IGFueSBjaGFuZ2UgaW4gdGhlIG91dHB1dCB3aWxsIGNhdXNlIHRoZSBhc3NldCB0b1xuICAgKiBiZSBpbnZhbGlkYXRlZCBhbmQgdXBsb2FkZWQuIEJlYXIgaW4gbWluZCB0aGF0IGBwaXBgIGFkZHMgdGltZXN0YW1wcyB0b1xuICAgKiBkZXBlbmRlbmNpZXMgaXQgaW5zdGFsbHMsIHdoaWNoIGltcGxpZXMgdGhhdCBpbiB0aGlzIG1vZGUgUHl0aG9uIGJ1bmRsZXNcbiAgICogd2lsbCBfYWx3YXlzXyBnZXQgcmVidWlsZCBhbmQgdXBsb2FkZWQuIE5vcm1hbGx5IHRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuXG4gICAqIHNpbmNlIGJ1aWxkXG4gICAqXG4gICAqIEBkZWZhdWx0IEFzc2V0SGFzaFR5cGUuU09VUkNFIEJ5IGRlZmF1bHQsIGhhc2ggaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGVcbiAgICogY29udGVudHMgb2YgdGhlIHNvdXJjZSBkaXJlY3RvcnkuIElmIGBhc3NldEhhc2hgIGlzIGFsc28gc3BlY2lmaWVkLCB0aGVcbiAgICogZGVmYXVsdCBpcyBgQ1VTVE9NYC4gVGhpcyBtZWFucyB0aGF0IG9ubHkgdXBkYXRlcyB0byB0aGUgc291cmNlIHdpbGwgY2F1c2VcbiAgICogdGhlIGFzc2V0IHRvIHJlYnVpbGQuXG4gICAqL1xuICByZWFkb25seSBhc3NldEhhc2hUeXBlPzogY2RrLkFzc2V0SGFzaFR5cGU7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBjdXN0b20gaGFzaCBmb3IgdGhpcyBhc3NldC4gSWYgYGFzc2V0SGFzaFR5cGVgIGlzIHNldCBpdCBtdXN0XG4gICAqIGJlIHNldCB0byBgQXNzZXRIYXNoVHlwZS5DVVNUT01gLiBGb3IgY29uc2lzdGVuY3ksIHRoaXMgY3VzdG9tIGhhc2ggd2lsbFxuICAgKiBiZSBTSEEyNTYgaGFzaGVkIGFuZCBlbmNvZGVkIGFzIGhleC4gVGhlIHJlc3VsdGluZyBoYXNoIHdpbGwgYmUgdGhlIGFzc2V0XG4gICAqIGhhc2guXG4gICAqXG4gICAqIE5PVEU6IHRoZSBoYXNoIGlzIHVzZWQgaW4gb3JkZXIgdG8gaWRlbnRpZnkgYSBzcGVjaWZpYyByZXZpc2lvbiBvZiB0aGUgYXNzZXQsIGFuZFxuICAgKiB1c2VkIGZvciBvcHRpbWl6aW5nIGFuZCBjYWNoaW5nIGRlcGxveW1lbnQgYWN0aXZpdGllcyByZWxhdGVkIHRvIHRoaXMgYXNzZXQgc3VjaCBhc1xuICAgKiBwYWNrYWdpbmcsIHVwbG9hZGluZyB0byBBbWF6b24gUzMsIGV0Yy4gSWYgeW91IGNob3NlIHRvIGN1c3RvbWl6ZSB0aGUgaGFzaCwgeW91IHdpbGxcbiAgICogbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgdXBkYXRlZCBldmVyeSB0aW1lIHRoZSBhc3NldCBjaGFuZ2VzLCBvciBvdGhlcndpc2UgaXQgaXNcbiAgICogcG9zc2libGUgdGhhdCBzb21lIGRlcGxveW1lbnRzIHdpbGwgbm90IGJlIGludmFsaWRhdGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGJhc2VkIG9uIGBhc3NldEhhc2hUeXBlYFxuICAgKi9cbiAgcmVhZG9ubHkgYXNzZXRIYXNoPzogc3RyaW5nO1xuXG4gIHJlYWRvbmx5IGluc3RhbGxDb21tYW5kcz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFByb2R1Y2UgYnVuZGxlZCBMYW1iZGEgYXNzZXQgY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVuZGxlKG9wdGlvbnM6IEJ1bmRsaW5nT3B0aW9ucyk6IGxhbWJkYS5Bc3NldENvZGUge1xuICBjb25zdCB7IGVudHJ5LCBydW50aW1lLCBvdXRwdXRQYXRoU3VmZml4LCBpbnN0YWxsQ29tbWFuZHMgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgc3RhZ2VkaXIgPSBjZGsuRmlsZVN5c3RlbS5ta2R0ZW1wKFwicHl0aG9uLWJ1bmRsaW5nLVwiKTtcbiAgY29uc3QgaGFzRGVwcyA9IHN0YWdlRGVwZW5kZW5jaWVzKGVudHJ5LCBzdGFnZWRpcik7XG4gIGNvbnN0IGhhc0luc3RhbGxDb21tYW5kcyA9IHN0YWdlSW5zdGFsbENvbW1hbmRzKFxuICAgIGluc3RhbGxDb21tYW5kcyB8fCBbXSxcbiAgICBzdGFnZWRpclxuICApO1xuXG4gIGNvbnN0IGRlcHNDb21tYW5kID0gY2hhaW4oW1xuICAgIGhhc0RlcHMgfHwgaGFzSW5zdGFsbENvbW1hbmRzXG4gICAgICA/IGByc3luYyAtciAke0JVTkRMRVJfREVQRU5ERU5DSUVTX0NBQ0hFfS8uICR7Y2RrLkFzc2V0U3RhZ2luZy5CVU5ETElOR19PVVRQVVRfRElSfS8ke291dHB1dFBhdGhTdWZmaXh9YFxuICAgICAgOiBcIlwiLFxuICAgIGByc3luYyAtciAuICR7Y2RrLkFzc2V0U3RhZ2luZy5CVU5ETElOR19PVVRQVVRfRElSfS8ke291dHB1dFBhdGhTdWZmaXh9YCxcbiAgXSk7XG5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGRvY2tlcmZpbGUgdG8gdXNlLiBXaGVuIGRlcGVuZGVuY2llcyBhcmUgcHJlc2VudCwgd2UgdXNlIGFcbiAgLy8gRG9ja2VyZmlsZSB0aGF0IGNhbiBjcmVhdGUgYSBjYWNoZWFibGUgbGF5ZXIuIFdlIGNhbid0IHVzZSB0aGlzIERvY2tlcmZpbGVcbiAgLy8gaWYgdGhlcmUgYXJlbid0IGRlcGVuZGVuY2llcyBvciB0aGUgRG9ja2VyZmlsZSB3aWxsIGNvbXBsYWluIGFib3V0IG1pc3NpbmdcbiAgLy8gc291cmNlcy5cbiAgY29uc3QgZG9ja2VyZmlsZSA9IGhhc0luc3RhbGxDb21tYW5kc1xuICAgID8gXCJEb2NrZXJmaWxlLmN1c3RvbVwiXG4gICAgOiBoYXNEZXBzXG4gICAgPyBcIkRvY2tlcmZpbGUuZGVwZW5kZW5jaWVzXCJcbiAgICA6IFwiRG9ja2VyZmlsZVwiO1xuXG4gIC8vIGNvcHkgRG9ja2VyZmlsZSB0byB3b3JrZGlyXG4gIGZzLmNvcHlGaWxlU3luYyhcbiAgICBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uLy4uLy4uL2Fzc2V0cy9weXRob25cIiwgZG9ja2VyZmlsZSksXG4gICAgcGF0aC5qb2luKHN0YWdlZGlyLCBkb2NrZXJmaWxlKVxuICApO1xuXG4gIGNvbnN0IGltYWdlID0gY2RrLkRvY2tlckltYWdlLmZyb21CdWlsZChzdGFnZWRpciwge1xuICAgIGJ1aWxkQXJnczoge1xuICAgICAgSU1BR0U6IHJ1bnRpbWUuYnVuZGxpbmdJbWFnZS5pbWFnZSxcbiAgICB9LFxuICAgIGZpbGU6IGRvY2tlcmZpbGUsXG4gIH0pO1xuXG4gIHJldHVybiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoZW50cnksIHtcbiAgICBhc3NldEhhc2hUeXBlOiBvcHRpb25zLmFzc2V0SGFzaFR5cGUsXG4gICAgYXNzZXRIYXNoOiBvcHRpb25zLmFzc2V0SGFzaCxcbiAgICBleGNsdWRlOiBERVBFTkRFTkNZX0VYQ0xVREVTLFxuICAgIGJ1bmRsaW5nOiB7XG4gICAgICBpbWFnZSxcbiAgICAgIGNvbW1hbmQ6IFtcImJhc2hcIiwgXCItY1wiLCBkZXBzQ29tbWFuZF0sXG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgYGVudHJ5YCBkaXJlY3RvcnkgY29udGFpbnMgYSB0eXBlIG9mIGRlcGVuZGVuY3kgdGhhdFxuICogd2Uga25vdyBob3cgdG8gaW5zdGFsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWdlRGVwZW5kZW5jaWVzKGVudHJ5OiBzdHJpbmcsIHN0YWdlZGlyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcHJlZml4ZXMgPSBbXCJQaXBmaWxlXCIsIFwicHlwcm9qZWN0XCIsIFwicG9ldHJ5XCIsIFwicmVxdWlyZW1lbnRzLnR4dFwiXTtcblxuICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZzLnJlYWRkaXJTeW5jKGVudHJ5KSkge1xuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICBpZiAoZmlsZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgZnMuY29weUZpbGVTeW5jKHBhdGguam9pbihlbnRyeSwgZmlsZSksIHBhdGguam9pbihzdGFnZWRpciwgZmlsZSkpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBzdGFnZUluc3RhbGxDb21tYW5kcyhcbiAgaW5zdGFsbENvbW1hbmRzOiBzdHJpbmdbXSxcbiAgc3RhZ2VkaXI6IHN0cmluZ1xuKTogYm9vbGVhbiB7XG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBpZiAoaW5zdGFsbENvbW1hbmRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihzdGFnZWRpciwgXCJzc3QtZGVwcy1pbnN0YWxsLWNvbW1hbmQuc2hcIik7XG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgaW5zdGFsbENvbW1hbmRzLmpvaW4oXCIgJiYgXCIpKTtcbiAgICBmcy5jaG1vZFN5bmMoZmlsZVBhdGgsIFwiNzU1XCIpO1xuICAgIGZvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY2hhaW4oY29tbWFuZHM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNvbW1hbmRzLmZpbHRlcigoYykgPT4gISFjKS5qb2luKFwiICYmIFwiKTtcbn1cbiJdfQ==