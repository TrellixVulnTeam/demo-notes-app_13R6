"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLApi = void 0;
const App_1 = require("./App");
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const Api_1 = require("./Api");
/**
 * The `GraphQLApi` construct is a higher level CDK construct that makes it easy to create GraphQL servers with AWS Lambda. It provides a simple way to define the GraphQL handler route in your API. And allows you to configure the specific Lambda function if necessary. It also allows you to configure authorization, custom domains, etc.
 *
 * The `GraphQLApi` construct internally extends the [`Api`](Api) construct.
 *
 * @example
 * ### Using the minimal config
 *
 * ```js
 * import { GraphQLApi } from "@serverless-stack/resources";
 *
 * new GraphQLApi(stack, "Api", {
 *   server: "src/graphql.handler",
 * });
 * ```
 */
class GraphQLApi extends Api_1.Api {
    constructor(scope, id, props) {
        if ("routes" in props || !props.server) {
            throw new Error(`Please use the "server" option instead of the "routes" to configure the handler for the "${id}" GraphQLApi`);
        }
        if (props.codegen) {
            const app = App_1.App.of(scope);
            if (!app.local) {
                const result = cross_spawn_1.default.sync("npx", ["graphql-codegen", "-c", props.codegen], {
                    stdio: "inherit",
                });
                if (result.status !== 0) {
                    throw new Error(`Failed to generate the schema for the "${id}" GraphQLApi`);
                }
            }
        }
        const rootPath = props.rootPath || "/";
        super(scope, id, Object.assign(Object.assign({}, props), { routes: {
                [`GET ${rootPath}`]: { function: props.server },
                [`POST ${rootPath}`]: { function: props.server },
            } }));
        this.rootPath = rootPath;
        this.codegen = props.codegen;
    }
    get serverFunction() {
        const serverFn = this.getFunction(`GET ${this.rootPath}`);
        // This should never happen
        if (!serverFn) {
            throw new Error(`Failed to get "serverFunction" in the "${this.node.id}" GraphQLApi`);
        }
        return serverFn;
    }
    // Note: We want to create 1 Lambda handling both the GET and POST request.
    //       This design is based on this discussion on GitHub
    //       https://github.com/serverless-stack/serverless-stack/issues/601
    // Also Note: We cannot use the "ANY /" route because if authorization
    //            were provided, the OPTIONS route will be protected. This
    //            causes CORS to fail.
    // Solution: We will override the createFunctionIntegration() function, and
    //           it will re-use the same Route Integration for all routes.
    createFunctionIntegration(scope, routeKey, routeProps, postfixName) {
        if (!this.lambdaIntegration) {
            this.lambdaIntegration = super.createFunctionIntegration(scope, routeKey, routeProps, postfixName);
        }
        return this.lambdaIntegration;
    }
    getConstructMetadata() {
        const parent = super.getConstructMetadata();
        return Object.assign(Object.assign({}, parent), { data: Object.assign(Object.assign({}, parent.data), { graphql: true, codegen: this.codegen }) });
    }
}
exports.GraphQLApi = GraphQLApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JhcGhRTEFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9HcmFwaFFMQXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLCtCQUE0QjtBQUM1Qiw4REFBZ0M7QUFFaEMsK0JBQTZEO0FBOEI3RDs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxNQUFhLFVBQVcsU0FBUSxTQUFHO0lBS2pDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBc0I7UUFDOUQsSUFBSSxRQUFRLElBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUksS0FBSyxDQUNiLDRGQUE0RixFQUFFLGNBQWMsQ0FDN0csQ0FBQztTQUNIO1FBRUQsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFO1lBQ2pCLE1BQU0sR0FBRyxHQUFHLFNBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFRLENBQUM7WUFDakMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUU7Z0JBQ2QsTUFBTSxNQUFNLEdBQUcscUJBQUssQ0FBQyxJQUFJLENBQ3ZCLEtBQUssRUFDTCxDQUFDLGlCQUFpQixFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQ3hDO29CQUNFLEtBQUssRUFBRSxTQUFTO2lCQUNqQixDQUNGLENBQUM7Z0JBQ0YsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDdkIsTUFBTSxJQUFJLEtBQUssQ0FDYiwwQ0FBMEMsRUFBRSxjQUFjLENBQzNELENBQUM7aUJBQ0g7YUFDRjtTQUNGO1FBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUM7UUFFdkMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLGtDQUNWLEtBQUssS0FDUixNQUFNLEVBQUU7Z0JBQ04sQ0FBQyxPQUFPLFFBQVEsRUFBRSxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRTtnQkFDL0MsQ0FBQyxRQUFRLFFBQVEsRUFBRSxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRTthQUNqRCxJQUNELENBQUM7UUFDSCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQVcsY0FBYztRQUN2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFMUQsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDBDQUEwQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsY0FBYyxDQUNyRSxDQUFDO1NBQ0g7UUFFRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQsMkVBQTJFO0lBQzNFLDBEQUEwRDtJQUMxRCx3RUFBd0U7SUFDeEUsc0VBQXNFO0lBQ3RFLHNFQUFzRTtJQUN0RSxrQ0FBa0M7SUFDbEMsMkVBQTJFO0lBQzNFLHNFQUFzRTtJQUM1RCx5QkFBeUIsQ0FDakMsS0FBZ0IsRUFDaEIsUUFBZ0IsRUFDaEIsVUFBeUMsRUFDekMsV0FBbUI7UUFFbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUMzQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDLHlCQUF5QixDQUN0RCxLQUFLLEVBQ0wsUUFBUSxFQUNSLFVBQVUsRUFDVixXQUFXLENBQ1osQ0FBQztTQUNIO1FBRUQsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUM7SUFDaEMsQ0FBQztJQUVNLG9CQUFvQjtRQUN6QixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUM1Qyx1Q0FDSyxNQUFNLEtBQ1QsSUFBSSxrQ0FDQyxNQUFNLENBQUMsSUFBSSxLQUNkLE9BQU8sRUFBRSxJQUFhLEVBQ3RCLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxPQUV2QjtJQUNKLENBQUM7Q0FDRjtBQTdGRCxnQ0E2RkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwUm91dGVJbnRlZ3JhdGlvbiB9IGZyb20gXCJAYXdzLWNkay9hd3MtYXBpZ2F0ZXdheXYyLWFscGhhXCI7XG5pbXBvcnQgeyBBcHAgfSBmcm9tIFwiLi9BcHBcIjtcbmltcG9ydCBzcGF3biBmcm9tIFwiY3Jvc3Mtc3Bhd25cIjtcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgeyBBcGksIEFwaUZ1bmN0aW9uUm91dGVQcm9wcywgQXBpUHJvcHMgfSBmcm9tIFwiLi9BcGlcIjtcbmltcG9ydCB7IEZ1bmN0aW9uIGFzIEZuLCBGdW5jdGlvbkRlZmluaXRpb24gfSBmcm9tIFwiLi9GdW5jdGlvblwiO1xuaW1wb3J0IHsgVmFsaWRhdGUgfSBmcm9tIFwiLi91dGlsL3ZhbGlkYXRlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGhRTEFwaVByb3BzIGV4dGVuZHMgT21pdDxBcGlQcm9wcywgXCJyb3V0ZXNcIj4ge1xuICAvKipcbiAgICogUGF0aCB0byBncmFwaHFsLWNvZGVnZW4gY29uZmlndXJhdGlvbiBmaWxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBHcmFwaFFMQXBpKHN0YWNrLCBcImFwaVwiLCB7XG4gICAqICAgY29kZWdlbjogXCIuL2dyYXBocWwvY29kZWdlbi55bWxcIlxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGNvZGVnZW4/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBQYXRoIHRvIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHRvIHJlc29sdmUgR3JhcGhRTCBxdWVyaWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBuZXcgR3JhcGhRTEFwaShzdGFjaywgXCJhcGlcIiwge1xuICAgKiAgIGNvZGVnZW46IFwiLi9ncmFwaHFsL2NvZGVnZW4ueW1sXCJcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzZXJ2ZXI6IEZ1bmN0aW9uRGVmaW5pdGlvbjtcbiAgcm9vdFBhdGg/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhlIGBHcmFwaFFMQXBpYCBjb25zdHJ1Y3QgaXMgYSBoaWdoZXIgbGV2ZWwgQ0RLIGNvbnN0cnVjdCB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gY3JlYXRlIEdyYXBoUUwgc2VydmVycyB3aXRoIEFXUyBMYW1iZGEuIEl0IHByb3ZpZGVzIGEgc2ltcGxlIHdheSB0byBkZWZpbmUgdGhlIEdyYXBoUUwgaGFuZGxlciByb3V0ZSBpbiB5b3VyIEFQSS4gQW5kIGFsbG93cyB5b3UgdG8gY29uZmlndXJlIHRoZSBzcGVjaWZpYyBMYW1iZGEgZnVuY3Rpb24gaWYgbmVjZXNzYXJ5LiBJdCBhbHNvIGFsbG93cyB5b3UgdG8gY29uZmlndXJlIGF1dGhvcml6YXRpb24sIGN1c3RvbSBkb21haW5zLCBldGMuXG4gKlxuICogVGhlIGBHcmFwaFFMQXBpYCBjb25zdHJ1Y3QgaW50ZXJuYWxseSBleHRlbmRzIHRoZSBbYEFwaWBdKEFwaSkgY29uc3RydWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVXNpbmcgdGhlIG1pbmltYWwgY29uZmlnXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IEdyYXBoUUxBcGkgfSBmcm9tIFwiQHNlcnZlcmxlc3Mtc3RhY2svcmVzb3VyY2VzXCI7XG4gKlxuICogbmV3IEdyYXBoUUxBcGkoc3RhY2ssIFwiQXBpXCIsIHtcbiAqICAgc2VydmVyOiBcInNyYy9ncmFwaHFsLmhhbmRsZXJcIixcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHcmFwaFFMQXBpIGV4dGVuZHMgQXBpIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlZ2VuPzogc3RyaW5nO1xuICBwcml2YXRlIGxhbWJkYUludGVncmF0aW9uPzogSHR0cFJvdXRlSW50ZWdyYXRpb247XG4gIHByaXZhdGUgcm9vdFBhdGg/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEdyYXBoUUxBcGlQcm9wcykge1xuICAgIGlmIChcInJvdXRlc1wiIGluIHByb3BzIHx8ICFwcm9wcy5zZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBsZWFzZSB1c2UgdGhlIFwic2VydmVyXCIgb3B0aW9uIGluc3RlYWQgb2YgdGhlIFwicm91dGVzXCIgdG8gY29uZmlndXJlIHRoZSBoYW5kbGVyIGZvciB0aGUgXCIke2lkfVwiIEdyYXBoUUxBcGlgXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5jb2RlZ2VuKSB7XG4gICAgICBjb25zdCBhcHAgPSBBcHAub2Yoc2NvcGUpIGFzIEFwcDtcbiAgICAgIGlmICghYXBwLmxvY2FsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwYXduLnN5bmMoXG4gICAgICAgICAgXCJucHhcIixcbiAgICAgICAgICBbXCJncmFwaHFsLWNvZGVnZW5cIiwgXCItY1wiLCBwcm9wcy5jb2RlZ2VuXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGRpbzogXCJpbmhlcml0XCIsXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUgdGhlIHNjaGVtYSBmb3IgdGhlIFwiJHtpZH1cIiBHcmFwaFFMQXBpYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByb290UGF0aCA9IHByb3BzLnJvb3RQYXRoIHx8IFwiL1wiO1xuXG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJvdXRlczoge1xuICAgICAgICBbYEdFVCAke3Jvb3RQYXRofWBdOiB7IGZ1bmN0aW9uOiBwcm9wcy5zZXJ2ZXIgfSxcbiAgICAgICAgW2BQT1NUICR7cm9vdFBhdGh9YF06IHsgZnVuY3Rpb246IHByb3BzLnNlcnZlciB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLnJvb3RQYXRoID0gcm9vdFBhdGg7XG4gICAgdGhpcy5jb2RlZ2VuID0gcHJvcHMuY29kZWdlbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2VydmVyRnVuY3Rpb24oKTogRm4ge1xuICAgIGNvbnN0IHNlcnZlckZuID0gdGhpcy5nZXRGdW5jdGlvbihgR0VUICR7dGhpcy5yb290UGF0aH1gKTtcblxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgIGlmICghc2VydmVyRm4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgXCJzZXJ2ZXJGdW5jdGlvblwiIGluIHRoZSBcIiR7dGhpcy5ub2RlLmlkfVwiIEdyYXBoUUxBcGlgXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzZXJ2ZXJGbjtcbiAgfVxuXG4gIC8vIE5vdGU6IFdlIHdhbnQgdG8gY3JlYXRlIDEgTGFtYmRhIGhhbmRsaW5nIGJvdGggdGhlIEdFVCBhbmQgUE9TVCByZXF1ZXN0LlxuICAvLyAgICAgICBUaGlzIGRlc2lnbiBpcyBiYXNlZCBvbiB0aGlzIGRpc2N1c3Npb24gb24gR2l0SHViXG4gIC8vICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXJ2ZXJsZXNzLXN0YWNrL3NlcnZlcmxlc3Mtc3RhY2svaXNzdWVzLzYwMVxuICAvLyBBbHNvIE5vdGU6IFdlIGNhbm5vdCB1c2UgdGhlIFwiQU5ZIC9cIiByb3V0ZSBiZWNhdXNlIGlmIGF1dGhvcml6YXRpb25cbiAgLy8gICAgICAgICAgICB3ZXJlIHByb3ZpZGVkLCB0aGUgT1BUSU9OUyByb3V0ZSB3aWxsIGJlIHByb3RlY3RlZC4gVGhpc1xuICAvLyAgICAgICAgICAgIGNhdXNlcyBDT1JTIHRvIGZhaWwuXG4gIC8vIFNvbHV0aW9uOiBXZSB3aWxsIG92ZXJyaWRlIHRoZSBjcmVhdGVGdW5jdGlvbkludGVncmF0aW9uKCkgZnVuY3Rpb24sIGFuZFxuICAvLyAgICAgICAgICAgaXQgd2lsbCByZS11c2UgdGhlIHNhbWUgUm91dGUgSW50ZWdyYXRpb24gZm9yIGFsbCByb3V0ZXMuXG4gIHByb3RlY3RlZCBjcmVhdGVGdW5jdGlvbkludGVncmF0aW9uKFxuICAgIHNjb3BlOiBDb25zdHJ1Y3QsXG4gICAgcm91dGVLZXk6IHN0cmluZyxcbiAgICByb3V0ZVByb3BzOiBBcGlGdW5jdGlvblJvdXRlUHJvcHM8c3RyaW5nPixcbiAgICBwb3N0Zml4TmFtZTogc3RyaW5nXG4gICk6IEh0dHBSb3V0ZUludGVncmF0aW9uIHtcbiAgICBpZiAoIXRoaXMubGFtYmRhSW50ZWdyYXRpb24pIHtcbiAgICAgIHRoaXMubGFtYmRhSW50ZWdyYXRpb24gPSBzdXBlci5jcmVhdGVGdW5jdGlvbkludGVncmF0aW9uKFxuICAgICAgICBzY29wZSxcbiAgICAgICAgcm91dGVLZXksXG4gICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgIHBvc3RmaXhOYW1lXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhbWJkYUludGVncmF0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldENvbnN0cnVjdE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHN1cGVyLmdldENvbnN0cnVjdE1ldGFkYXRhKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcmVudCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgLi4ucGFyZW50LmRhdGEsXG4gICAgICAgIGdyYXBocWw6IHRydWUgYXMgY29uc3QsXG4gICAgICAgIGNvZGVnZW46IHRoaXMuY29kZWdlbixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuIl19