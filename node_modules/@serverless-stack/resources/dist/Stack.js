"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stack = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const cdk = __importStar(require("aws-cdk-lib"));
const regionInfo = __importStar(require("aws-cdk-lib/region-info"));
const Function_1 = require("./Function");
const Construct_1 = require("./Construct");
/**
 * The Stack construct extends cdk.Stack. It automatically prefixes the stack names with the stage and app name to ensure that they can be deployed to multiple regions in the same AWS account. It also ensure that the stack uses the same AWS profile and region as the app. They're defined using functions that return resources that can be imported by other stacks.
 *
 * @example
 * ### Creating a new stack
 *
 * ```js
 * import { StackContext } from "@serverless-stack/resources";
 *
 * export function MyStack({ stack }: StackContext) {
 *   // Define your stack
 * }
 * ```
 */
class Stack extends cdk.Stack {
    constructor(scope, id, props) {
        const root = scope.node.root;
        const stackId = root.logicalPrefixedName(id);
        Stack.checkForPropsIsConstruct(id, props);
        Stack.checkForEnvInProps(id, props);
        super(scope, stackId, Object.assign(Object.assign({}, props), { env: {
                account: process.env.CDK_DEFAULT_ACCOUNT,
                region: root.region,
            } }));
        this.stage = root.stage;
        this.defaultFunctionProps = root.defaultFunctionProps.map((dfp) => typeof dfp === "function" ? dfp(this) : dfp);
        this.metadata = this.createMetadataResource();
    }
    /**
     * The default function props to be applied to all the Lambda functions in the stack.
     *
     * @example
     * ```js
     * stack.setDefaultFunctionProps({
     *   srcPath: "backend",
     *   runtime: "nodejs16.x",
     * });
     * ```
     */
    setDefaultFunctionProps(props) {
        const fns = this.getAllFunctions();
        if (fns.length > 0)
            throw new Error("Default function props for the stack must be set before any functions have been added. Use 'addDefaultFunctionEnv' or 'addDefaultFunctionPermissions' instead to add more default properties.");
        this.defaultFunctionProps.push(props);
    }
    /**
     * Adds additional default Permissions to be applied to all Lambda functions in the stack.
     *
     * @example
     * ```js
     * stack.addDefaultFunctionPermissions(["sqs", "s3"]);
     * ```
     */
    addDefaultFunctionPermissions(permissions) {
        this.defaultFunctionProps.push({
            permissions,
        });
    }
    /**
     * Adds additional default environment variables to be applied to all Lambda functions in the stack.
     *
     * @example
     * ```js
     * stack.addDefaultFunctionEnv({
     *   DYNAMO_TABLE: table.name
     * });
     * ```
     */
    addDefaultFunctionEnv(environment) {
        this.defaultFunctionProps.push({
            environment,
        });
    }
    /**
     * Adds additional default layers to be applied to all Lambda functions in the stack.
     *
     * @example
     * ```js
     * stack.addDefaultFunctionLayers(["arn:aws:lambda:us-east-1:123456789012:layer:nodejs:3"]);
     * ```
     */
    addDefaultFunctionLayers(layers) {
        this.defaultFunctionProps.push({
            layers,
        });
    }
    /**
     * Returns all the Function instances in this stack.
     *
     * @example
     * ```js
     * stack.getAllFunctions();
     * ```
     */
    getAllFunctions() {
        return this.doGetAllFunctions(this);
    }
    doGetAllFunctions(construct) {
        const results = [];
        for (const child of construct.node.children) {
            if (child instanceof Function_1.Function)
                results.push(child);
            results.push(...this.doGetAllFunctions(child));
        }
        return results;
    }
    /**
     * Add outputs to this stack
     *
     * @example
     * ```js
     * stack.addOutputs({
     *   TableName: table.name,
     * });
     * ```
     *
     * ```js
     * stack.addOutputs({
     *   TableName: {
     *     value: table.name,
     *     exportName: "MyTableName",
     *   }
     * });
     * ```
     */
    addOutputs(outputs) {
        Object.keys(outputs).forEach((key) => {
            const value = outputs[key];
            if (value === undefined) {
                throw new Error(`The stack output "${key}" is undefined`);
            }
            else if (typeof value === "string") {
                new cdk.CfnOutput(this, key, { value });
            }
            else {
                new cdk.CfnOutput(this, key, value);
            }
        });
    }
    addConstructsMetadata(metadata) {
        this.metadata.addMetadata("sst:constructs", metadata);
    }
    createMetadataResource() {
        // Add a placeholder resource to ensure stacks with just an imported construct
        // has at least 1 resource, so the deployment succeeds.
        // For example: users often create a stack and use it to import a VPC. The
        //              stack does not have any resources.
        //
        // Note that the "AWS::CDK::Metadata" resource does not exist in GovCloud
        // and a few other regions. In this case, we will use the "AWS::SSM::Parameter"
        // resource. It does not matter what resource type we use. All we are interested
        // in is the Metadata.
        const props = this.isCDKMetadataResourceSupported()
            ? {
                type: "AWS::CDK::Metadata",
            }
            : {
                type: "AWS::SSM::Parameter",
                properties: {
                    Type: "String",
                    Name: `/sst/${this.stackName}`,
                    Value: "metadata-placeholder",
                    Description: "Parameter added by SST for storing stack metadata",
                },
            };
        const res = new cdk.CfnResource(this, "SSTMetadata", props);
        // Add version metadata
        const packageJson = fs.readJsonSync(path.join(__dirname, "..", "package.json"));
        res.addMetadata("sst:version", packageJson.version);
        return res;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static checkForPropsIsConstruct(id, props) {
        // If a construct is passed in as stack props, let's detect it and throw a
        // friendlier error.
        if (props && (0, Construct_1.isConstruct)(props)) {
            throw new Error(`Expected an associative array as the stack props while initializing "${id}" stack. Received a construct instead.`);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static checkForEnvInProps(id, props) {
        if (props && props.env) {
            let envS = "";
            try {
                envS = " (" + JSON.stringify(props.env) + ")";
            }
            catch (e) {
                // Ignore
            }
            throw new Error(`Do not set the "env" prop while initializing "${id}" stack${envS}. Use the "AWS_PROFILE" environment variable and "--region" CLI option instead.`);
        }
    }
    isCDKMetadataResourceSupported() {
        const app = this.node.root;
        // CDK Metadata resource currently not supported in the region
        if (!regionInfo.RegionInfo.get(app.region).cdkMetadataResourceAvailable) {
            return false;
        }
        // CDK Metadata resource used to not supported in the region
        // Note that b/c we cannot change the resource type of a given logical id,
        //           so if it used to not support, we will continue to mark it not
        //           supportd.
        if ([
            "us-gov-east-1",
            "us-gov-west-1",
            "us-iso-east-1",
            "us-isob-east-1",
            "ap-northeast-3",
        ].includes(app.region)) {
            return false;
        }
        return true;
    }
}
exports.Stack = Stack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvU3RhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFDN0IsNkNBQStCO0FBRS9CLGlEQUFtQztBQUVuQyxvRUFBc0Q7QUFDdEQseUNBQTJEO0FBRTNELDJDQUEwQztBQUsxQzs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsTUFBYSxLQUFNLFNBQVEsR0FBRyxDQUFDLEtBQUs7SUFZbEMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUFrQjtRQUMxRCxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVcsQ0FBQztRQUNwQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFN0MsS0FBSyxDQUFDLHdCQUF3QixDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMxQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRXBDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxrQ0FDZixLQUFLLEtBQ1IsR0FBRyxFQUFFO2dCQUNILE9BQU8sRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQjtnQkFDeEMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2FBQ3BCLElBQ0QsQ0FBQztRQUVILElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ2hFLE9BQU8sR0FBRyxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQzVDLENBQUM7UUFFRixJQUFJLENBQUMsUUFBUSxH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Z0JBQ1YsU0FBUzthQUNWO1lBRUQsTUFBTSxJQUFJLEtBQUssQ0FDYixpREFBaUQsRUFBRSxVQUFVLElBQUksaUZBQWlGLENBQ25KLENBQUM7U0FDSDtJQUNILENBQUM7SUFFTyw4QkFBOEI7UUFDcEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFXLENBQUM7UUFFbEMsOERBQThEO1FBQzlELElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsNEJBQTRCLEVBQUU7WUFDdkUsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELDREQUE0RDtRQUM1RCwwRUFBMEU7UUFDMUUsMEVBQTBFO1FBQzFFLHNCQUFzQjtRQUN0QixJQUNFO1lBQ0UsZUFBZTtZQUNmLGVBQWU7WUFDZixlQUFlO1lBQ2YsZ0JBQWdCO1lBQ2hCLGdCQUFnQjtTQUNqQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQ3RCO1lBQ0EsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGO0FBdFBELHNCQXNQQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0IHsgQ29uc3RydWN0LCBJQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCAqIGFzIGNkayBmcm9tIFwiYXdzLWNkay1saWJcIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWxhbWJkYVwiO1xuaW1wb3J0ICogYXMgcmVnaW9uSW5mbyBmcm9tIFwiYXdzLWNkay1saWIvcmVnaW9uLWluZm9cIjtcbmltcG9ydCB7IEZ1bmN0aW9uUHJvcHMsIEZ1bmN0aW9uIGFzIEZuIH0gZnJvbSBcIi4vRnVuY3Rpb25cIjtcbmltcG9ydCB7IEFwcCB9IGZyb20gXCIuL0FwcFwiO1xuaW1wb3J0IHsgaXNDb25zdHJ1Y3QgfSBmcm9tIFwiLi9Db25zdHJ1Y3RcIjtcbmltcG9ydCB7IFBlcm1pc3Npb25zIH0gZnJvbSBcIi4vdXRpbC9wZXJtaXNzaW9uXCI7XG5cbmV4cG9ydCB0eXBlIFN0YWNrUHJvcHMgPSBjZGsuU3RhY2tQcm9wcztcblxuLyoqXG4gKiBUaGUgU3RhY2sgY29uc3RydWN0IGV4dGVuZHMgY2RrLlN0YWNrLiBJdCBhdXRvbWF0aWNhbGx5IHByZWZpeGVzIHRoZSBzdGFjayBuYW1lcyB3aXRoIHRoZSBzdGFnZSBhbmQgYXBwIG5hbWUgdG8gZW5zdXJlIHRoYXQgdGhleSBjYW4gYmUgZGVwbG95ZWQgdG8gbXVsdGlwbGUgcmVnaW9ucyBpbiB0aGUgc2FtZSBBV1MgYWNjb3VudC4gSXQgYWxzbyBlbnN1cmUgdGhhdCB0aGUgc3RhY2sgdXNlcyB0aGUgc2FtZSBBV1MgcHJvZmlsZSBhbmQgcmVnaW9uIGFzIHRoZSBhcHAuIFRoZXkncmUgZGVmaW5lZCB1c2luZyBmdW5jdGlvbnMgdGhhdCByZXR1cm4gcmVzb3VyY2VzIHRoYXQgY2FuIGJlIGltcG9ydGVkIGJ5IG90aGVyIHN0YWNrcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENyZWF0aW5nIGEgbmV3IHN0YWNrXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IFN0YWNrQ29udGV4dCB9IGZyb20gXCJAc2VydmVybGVzcy1zdGFjay9yZXNvdXJjZXNcIjtcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gTXlTdGFjayh7IHN0YWNrIH06IFN0YWNrQ29udGV4dCkge1xuICogICAvLyBEZWZpbmUgeW91ciBzdGFja1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFjayBleHRlbmRzIGNkay5TdGFjayB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGFnZSBvZiB0aGUgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc3RhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZGVmYXVsdEZ1bmN0aW9uUHJvcHM6IEZ1bmN0aW9uUHJvcHNbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBtZXRhZGF0YTogY2RrLkNmblJlc291cmNlO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzPzogU3RhY2tQcm9wcykge1xuICAgIGNvbnN0IHJvb3QgPSBzY29wZS5ub2RlLnJvb3QgYXMgQXBwO1xuICAgIGNvbnN0IHN0YWNrSWQgPSByb290LmxvZ2ljYWxQcmVmaXhlZE5hbWUoaWQpO1xuXG4gICAgU3RhY2suY2hlY2tGb3JQcm9wc0lzQ29uc3RydWN0KGlkLCBwcm9wcyk7XG4gICAgU3RhY2suY2hlY2tGb3JFbnZJblByb3BzKGlkLCBwcm9wcyk7XG5cbiAgICBzdXBlcihzY29wZSwgc3RhY2tJZCwge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBlbnY6IHtcbiAgICAgICAgYWNjb3VudDogcHJvY2Vzcy5lbnYuQ0RLX0RFRkFVTFRfQUNDT1VOVCxcbiAgICAgICAgcmVnaW9uOiByb290LnJlZ2lvbixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLnN0YWdlID0gcm9vdC5zdGFnZTtcbiAgICB0aGlzLmRlZmF1bHRGdW5jdGlvblByb3BzID0gcm9vdC5kZWZhdWx0RnVuY3Rpb25Qcm9wcy5tYXAoKGRmcCkgPT5cbiAgICAgIHR5cGVvZiBkZnAgPT09IFwiZnVuY3Rpb25cIiA/IGRmcCh0aGlzKSA6IGRmcFxuICAgICk7XG5cbiAgICB0aGlzLm1ldGFkYXRhID0gdGhpcy5jcmVhdGVNZXRhZGF0YVJlc291cmNlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gcHJvcHMgdG8gYmUgYXBwbGllZCB0byBhbGwgdGhlIExhbWJkYSBmdW5jdGlvbnMgaW4gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBzdGFjay5zZXREZWZhdWx0RnVuY3Rpb25Qcm9wcyh7XG4gICAqICAgc3JjUGF0aDogXCJiYWNrZW5kXCIsXG4gICAqICAgcnVudGltZTogXCJub2RlanMxNi54XCIsXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBzZXREZWZhdWx0RnVuY3Rpb25Qcm9wcyhwcm9wczogRnVuY3Rpb25Qcm9wcyk6IHZvaWQge1xuICAgIGNvbnN0IGZucyA9IHRoaXMuZ2V0QWxsRnVuY3Rpb25zKCk7XG4gICAgaWYgKGZucy5sZW5ndGggPiAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkRlZmF1bHQgZnVuY3Rpb24gcHJvcHMgZm9yIHRoZSBzdGFjayBtdXN0IGJlIHNldCBiZWZvcmUgYW55IGZ1bmN0aW9ucyBoYXZlIGJlZW4gYWRkZWQuIFVzZSAnYWRkRGVmYXVsdEZ1bmN0aW9uRW52JyBvciAnYWRkRGVmYXVsdEZ1bmN0aW9uUGVybWlzc2lvbnMnIGluc3RlYWQgdG8gYWRkIG1vcmUgZGVmYXVsdCBwcm9wZXJ0aWVzLlwiXG4gICAgICApO1xuICAgIHRoaXMuZGVmYXVsdEZ1bmN0aW9uUHJvcHMucHVzaChwcm9wcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhZGRpdGlvbmFsIGRlZmF1bHQgUGVybWlzc2lvbnMgdG8gYmUgYXBwbGllZCB0byBhbGwgTGFtYmRhIGZ1bmN0aW9ucyBpbiB0aGUgc3RhY2suXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHN0YWNrLmFkZERlZmF1bHRGdW5jdGlvblBlcm1pc3Npb25zKFtcInNxc1wiLCBcInMzXCJdKTtcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgYWRkRGVmYXVsdEZ1bmN0aW9uUGVybWlzc2lvbnMocGVybWlzc2lvbnM6IFBlcm1pc3Npb25zKSB7XG4gICAgdGhpcy5kZWZhdWx0RnVuY3Rpb25Qcm9wcy5wdXNoKHtcbiAgICAgIHBlcm1pc3Npb25zLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBkZWZhdWx0IGVudmlyb25tZW50IHZhcmlhYmxlcyB0byBiZSBhcHBsaWVkIHRvIGFsbCBMYW1iZGEgZnVuY3Rpb25zIGluIHRoZSBzdGFjay5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogc3RhY2suYWRkRGVmYXVsdEZ1bmN0aW9uRW52KHtcbiAgICogICBEWU5BTU9fVEFCTEU6IHRhYmxlLm5hbWVcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGFkZERlZmF1bHRGdW5jdGlvbkVudihlbnZpcm9ubWVudDogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIHRoaXMuZGVmYXVsdEZ1bmN0aW9uUHJvcHMucHVzaCh7XG4gICAgICBlbnZpcm9ubWVudCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFkZGl0aW9uYWwgZGVmYXVsdCBsYXllcnMgdG8gYmUgYXBwbGllZCB0byBhbGwgTGFtYmRhIGZ1bmN0aW9ucyBpbiB0aGUgc3RhY2suXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHN0YWNrLmFkZERlZmF1bHRGdW5jdGlvbkxheWVycyhbXCJhcm46YXdzOmxhbWJkYTp1cy1lYXN0LTE6MTIzNDU2Nzg5MDEyOmxheWVyOm5vZGVqczozXCJdKTtcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgYWRkRGVmYXVsdEZ1bmN0aW9uTGF5ZXJzKGxheWVyczogbGFtYmRhLklMYXllclZlcnNpb25bXSkge1xuICAgIHRoaXMuZGVmYXVsdEZ1bmN0aW9uUHJvcHMucHVzaCh7XG4gICAgICBsYXllcnMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIEZ1bmN0aW9uIGluc3RhbmNlcyBpbiB0aGlzIHN0YWNrLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBzdGFjay5nZXRBbGxGdW5jdGlvbnMoKTtcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgZ2V0QWxsRnVuY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRvR2V0QWxsRnVuY3Rpb25zKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBkb0dldEFsbEZ1bmN0aW9ucyhjb25zdHJ1Y3Q6IElDb25zdHJ1Y3QpIHtcbiAgICBjb25zdCByZXN1bHRzOiBGbltdID0gW107XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjb25zdHJ1Y3Qubm9kZS5jaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRm4pIHJlc3VsdHMucHVzaChjaGlsZCk7XG4gICAgICByZXN1bHRzLnB1c2goLi4udGhpcy5kb0dldEFsbEZ1bmN0aW9ucyhjaGlsZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb3V0cHV0cyB0byB0aGlzIHN0YWNrXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHN0YWNrLmFkZE91dHB1dHMoe1xuICAgKiAgIFRhYmxlTmFtZTogdGFibGUubmFtZSxcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBzdGFjay5hZGRPdXRwdXRzKHtcbiAgICogICBUYWJsZU5hbWU6IHtcbiAgICogICAgIHZhbHVlOiB0YWJsZS5uYW1lLFxuICAgKiAgICAgZXhwb3J0TmFtZTogXCJNeVRhYmxlTmFtZVwiLFxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGFkZE91dHB1dHMoXG4gICAgb3V0cHV0czogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgY2RrLkNmbk91dHB1dFByb3BzPlxuICApOiB2b2lkIHtcbiAgICBPYmplY3Qua2V5cyhvdXRwdXRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3V0cHV0c1trZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RhY2sgb3V0cHV0IFwiJHtrZXl9XCIgaXMgdW5kZWZpbmVkYCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuZXcgY2RrLkNmbk91dHB1dCh0aGlzLCBrZXksIHsgdmFsdWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXcgY2RrLkNmbk91dHB1dCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFkZENvbnN0cnVjdHNNZXRhZGF0YShtZXRhZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5tZXRhZGF0YS5hZGRNZXRhZGF0YShcInNzdDpjb25zdHJ1Y3RzXCIsIG1ldGFkYXRhKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlTWV0YWRhdGFSZXNvdXJjZSgpOiBjZGsuQ2ZuUmVzb3VyY2Uge1xuICAgIC8vIEFkZCBhIHBsYWNlaG9sZGVyIHJlc291cmNlIHRvIGVuc3VyZSBzdGFja3Mgd2l0aCBqdXN0IGFuIGltcG9ydGVkIGNvbnN0cnVjdFxuICAgIC8vIGhhcyBhdCBsZWFzdCAxIHJlc291cmNlLCBzbyB0aGUgZGVwbG95bWVudCBzdWNjZWVkcy5cbiAgICAvLyBGb3IgZXhhbXBsZTogdXNlcnMgb2Z0ZW4gY3JlYXRlIGEgc3RhY2sgYW5kIHVzZSBpdCB0byBpbXBvcnQgYSBWUEMuIFRoZVxuICAgIC8vICAgICAgICAgICAgICBzdGFjayBkb2VzIG5vdCBoYXZlIGFueSByZXNvdXJjZXMuXG4gICAgLy9cbiAgICAvLyBOb3RlIHRoYXQgdGhlIFwiQVdTOjpDREs6Ok1ldGFkYXRhXCIgcmVzb3VyY2UgZG9lcyBub3QgZXhpc3QgaW4gR292Q2xvdWRcbiAgICAvLyBhbmQgYSBmZXcgb3RoZXIgcmVnaW9ucy4gSW4gdGhpcyBjYXNlLCB3ZSB3aWxsIHVzZSB0aGUgXCJBV1M6OlNTTTo6UGFyYW1ldGVyXCJcbiAgICAvLyByZXNvdXJjZS4gSXQgZG9lcyBub3QgbWF0dGVyIHdoYXQgcmVzb3VyY2UgdHlwZSB3ZSB1c2UuIEFsbCB3ZSBhcmUgaW50ZXJlc3RlZFxuICAgIC8vIGluIGlzIHRoZSBNZXRhZGF0YS5cbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuaXNDREtNZXRhZGF0YVJlc291cmNlU3VwcG9ydGVkKClcbiAgICAgID8ge1xuICAgICAgICAgIHR5cGU6IFwiQVdTOjpDREs6Ok1ldGFkYXRhXCIsXG4gICAgICAgIH1cbiAgICAgIDoge1xuICAgICAgICAgIHR5cGU6IFwiQVdTOjpTU006OlBhcmFtZXRlclwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIFR5cGU6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICBOYW1lOiBgL3NzdC8ke3RoaXMuc3RhY2tOYW1lfWAsXG4gICAgICAgICAgICBWYWx1ZTogXCJtZXRhZGF0YS1wbGFjZWhvbGRlclwiLFxuICAgICAgICAgICAgRGVzY3JpcHRpb246IFwiUGFyYW1ldGVyIGFkZGVkIGJ5IFNTVCBmb3Igc3RvcmluZyBzdGFjayBtZXRhZGF0YVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgY29uc3QgcmVzID0gbmV3IGNkay5DZm5SZXNvdXJjZSh0aGlzLCBcIlNTVE1ldGFkYXRhXCIsIHByb3BzKTtcblxuICAgIC8vIEFkZCB2ZXJzaW9uIG1ldGFkYXRhXG4gICAgY29uc3QgcGFja2FnZUpzb24gPSBmcy5yZWFkSnNvblN5bmMoXG4gICAgICBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwicGFja2FnZS5qc29uXCIpXG4gICAgKTtcbiAgICByZXMuYWRkTWV0YWRhdGEoXCJzc3Q6dmVyc2lvblwiLCBwYWNrYWdlSnNvbi52ZXJzaW9uKTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBwcml2YXRlIHN0YXRpYyBjaGVja0ZvclByb3BzSXNDb25zdHJ1Y3QoaWQ6IHN0cmluZywgcHJvcHM/OiBhbnkpIHtcbiAgICAvLyBJZiBhIGNvbnN0cnVjdCBpcyBwYXNzZWQgaW4gYXMgc3RhY2sgcHJvcHMsIGxldCdzIGRldGVjdCBpdCBhbmQgdGhyb3cgYVxuICAgIC8vIGZyaWVuZGxpZXIgZXJyb3IuXG4gICAgaWYgKHByb3BzICYmIGlzQ29uc3RydWN0KHByb3BzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgYW4gYXNzb2NpYXRpdmUgYXJyYXkgYXMgdGhlIHN0YWNrIHByb3BzIHdoaWxlIGluaXRpYWxpemluZyBcIiR7aWR9XCIgc3RhY2suIFJlY2VpdmVkIGEgY29uc3RydWN0IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBwcml2YXRlIHN0YXRpYyBjaGVja0ZvckVudkluUHJvcHMoaWQ6IHN0cmluZywgcHJvcHM/OiBhbnkpIHtcbiAgICBpZiAocHJvcHMgJiYgcHJvcHMuZW52KSB7XG4gICAgICBsZXQgZW52UyA9IFwiXCI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVudlMgPSBcIiAoXCIgKyBKU09OLnN0cmluZ2lmeShwcm9wcy5lbnYpICsgXCIpXCI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEbyBub3Qgc2V0IHRoZSBcImVudlwiIHByb3Agd2hpbGUgaW5pdGlhbGl6aW5nIFwiJHtpZH1cIiBzdGFjayR7ZW52U30uIFVzZSB0aGUgXCJBV1NfUFJPRklMRVwiIGVudmlyb25tZW50IHZhcmlhYmxlIGFuZCBcIi0tcmVnaW9uXCIgQ0xJIG9wdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0NES01ldGFkYXRhUmVzb3VyY2VTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYXBwID0gdGhpcy5ub2RlLnJvb3QgYXMgQXBwO1xuXG4gICAgLy8gQ0RLIE1ldGFkYXRhIHJlc291cmNlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIHRoZSByZWdpb25cbiAgICBpZiAoIXJlZ2lvbkluZm8uUmVnaW9uSW5mby5nZXQoYXBwLnJlZ2lvbikuY2RrTWV0YWRhdGFSZXNvdXJjZUF2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENESyBNZXRhZGF0YSByZXNvdXJjZSB1c2VkIHRvIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIHJlZ2lvblxuICAgIC8vIE5vdGUgdGhhdCBiL2Mgd2UgY2Fubm90IGNoYW5nZSB0aGUgcmVzb3VyY2UgdHlwZSBvZiBhIGdpdmVuIGxvZ2ljYWwgaWQsXG4gICAgLy8gICAgICAgICAgIHNvIGlmIGl0IHVzZWQgdG8gbm90IHN1cHBvcnQsIHdlIHdpbGwgY29udGludWUgdG8gbWFyayBpdCBub3RcbiAgICAvLyAgICAgICAgICAgc3VwcG9ydGQuXG4gICAgaWYgKFxuICAgICAgW1xuICAgICAgICBcInVzLWdvdi1lYXN0LTFcIixcbiAgICAgICAgXCJ1cy1nb3Ytd2VzdC0xXCIsXG4gICAgICAgIFwidXMtaXNvLWVhc3QtMVwiLFxuICAgICAgICBcInVzLWlzb2ItZWFzdC0xXCIsXG4gICAgICAgIFwiYXAtbm9ydGhlYXN0LTNcIixcbiAgICAgIF0uaW5jbHVkZXMoYXBwLnJlZ2lvbilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIl19